<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React diff算法浅析</title>
    <link href="/2022/08/28/react/diff%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/28/react/diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="传统diif算法"><a href="#传统diif算法" class="headerlink" title="传统diif算法"></a>传统diif算法</h1><p>时间复杂度最优解为O( n^3 )，如果有1000个节点，diff就将进行十亿次比较，效率低下。</p><h1 id="优化diff算法"><a href="#优化diff算法" class="headerlink" title="优化diff算法"></a>优化diff算法</h1><p>时间复杂度为O(n)</p><h3 id="（1）两个假设"><a href="#（1）两个假设" class="headerlink" title="（1）两个假设"></a>（1）两个假设</h3><ol><li>两个不同类型的元素会产生出不同的树</li><li>开发者可以通过key prop来暗示哪些子元素在不同渲染模式下保持稳定</li></ol><h3 id="（2）三个策略"><a href="#（2）三个策略" class="headerlink" title="（2）三个策略"></a>（2）三个策略</h3><p>针对以上两个假设，React针对性的提出了三个策略进行优化</p><ol><li>web ui中DOM节点跨层级的移动操作步数特别少，可以忽略不计</li><li>用友相同类型的两个组件会产生相似的树形结构，不同类型的两个组件将会产生不同树形结构</li><li>对于同一层级的一组节点，可以通过唯一key进行区分</li></ol><h3 id="（3）diff具体优化"><a href="#（3）diff具体优化" class="headerlink" title="（3）diff具体优化"></a>（3）diff具体优化</h3><ul><li>tree diff</li><li>copoment diff</li><li>element diff</li></ul><h4 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h4><p>React 只对虚拟 DOM 树进行分层比较，不考虑节点的跨层级比较。如下图：</p><p><img src="/.com//diff%E7%AE%97%E6%B3%95/1661687331530.png" alt="1661687331530"></p><p>如上图，React 通过 updateDepth 对虚拟 Dom 树进行层级控制，只会对相同颜色框内的节点进行比较，根据对比结果，进行节点的新增和删除。如此只需要遍历一次虚拟 Dom 树，就可以完成整个的对比。</p><p>如果发生了跨层级的移动操作，如下图：<img src="/.com//diff%E7%AE%97%E6%B3%95/1661687936940.png" alt="1661687936940"></p><p>通过分层比较可知，React 并不会复用 B 节点及其子节点，而是会直接删除 A 节点下的 B 节点，然后再在 C 节点下创建新的 B 节点及其子节点。因此，如果发生跨级操作，React 是不能复用已有节点，可能会导致 React 进行大量重新创建操作，这会影响性能。所以 React 官方推荐尽量避免跨层级的操作。</p><h4 id="compenent-diff"><a href="#compenent-diff" class="headerlink" title="compenent diff"></a>compenent diff</h4><p>React 是基于组件构建的，对于组件间的比较所采用的策略如下：</p><ul><li>如果是同类型组件，首先使用 <code>shouldComponentUpdate()</code>方法判断是否需要进行比较，如果返回 <code>true</code>，继续按照 React diff 策略比较组件的虚拟 DOM 树，否则不需要比较</li><li>如果是不同类型的组件，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点<img src="/.com//diff%E7%AE%97%E6%B3%95/1661688908613.png" alt="1661688908613">如上图，虽然组件 C 和组件 H 结构相似，但类型不同，React 不会进行比较，会直接删除组件 C，创建组件 H。</li></ul><h4 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a><strong>element diff</strong></h4><p>element diff 涉及三种操作：移动、创建、删除。对于同一层级的子节点，对于是否使用 key 分别进行讨论。</p><p>对于不使用 key 的情况，如下图：</p><p>React 对新老同一层级的子节点对比，发现新集合中的 B 不等于老集合中的 A，于是删除 A，创建 B，依此类推，直到删除 D，创建 C。这会使得相同的节点不能复用，出现频繁的删除和创建操作，从而影响性能。</p><p><img src="https://file+.vscode-resource.vscode-cdn.net/f%3A/O1ive2Blog/source/_posts/react/image/diff%E7%AE%97%E6%B3%95/1661689056970.png" alt="1661689056970"></p><p>对于使用 key 的情况，如下图：</p><p><img src="/.com//diff%E7%AE%97%E6%B3%95/1661689693362.png" alt="1661689693362"></p><p>React 首先会对新集合进行遍历，通过唯一 key 来判断老集合中是否存在相同的节点，如果没有则创建，如果有的，则判断是否需要进行移动操作。并且 React 对于移动操作也采用了比较高效的算法，使用了一种顺序优化手段，这里不做详细讨论。</p><p>从上述可知，element diff 就是通过唯一 key 来进行 diff 优化，通过复用已有的节点，减少节点的删除和创建操作。</p><p><strong>（4）如何进行 diff</strong></p><p>上面已经说完了 React 的 diff 策略和具体优化，这里简单谈一下 React 是如何应用这些策略来进行 diff ：</p><p>React 是基于组件构建的，首先可以将整个虚拟 DOM 树，抽象为 React 组件树（每一个组件又是由一颗更小的组件树构成，依次类推），将 React diff 策略应用比较这颗组件树，若其中某个组件需要进行比较，将这个组件看成一颗较小的组件树，继续用 React diff 策略比较这颗较小的组件树，依次类推，直到层次遍历完所有的需要比较的组件。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h1><p>React 通过大胆的假设，制定对应的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题</p><ul><li>通过分层对比策略，对 tree diff 进行算法优化</li><li>通过相同类生成相似树形结构，不同类生成不同树形结构以及 <code>shouldComponentUpdate</code>策略，对 component diff 进行算法优化</li><li>通过设置唯一 key 策略，对 element diff 进行算法优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中间人攻击</title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPs原理"><a href="#HTTPs原理" class="headerlink" title="HTTPs原理"></a>HTTPs原理</h1><p>HTTPS本质上就是要对HTTP通信内容进行加密。使用非对称加密的方式。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>公钥用于加密，私钥用于解密</p><h1 id="中间人攻击方式"><a href="#中间人攻击方式" class="headerlink" title="中间人攻击方式"></a>中间人攻击方式</h1><ol><li>客户端寻求服务端的公钥</li><li>查询请求被中间人拦截</li><li>中间人把自身的公钥发送给客户端</li><li>中间人可以用自己的私钥解密客户端之后的一切通信信息</li></ol><h1 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h1><p>HTTPS协议设计的过程中，考虑到了这种情况，所以对于获取的公钥的过程做了一个验证，就是 <strong>证书验证机制</strong> 。</p><p>比如访问百度的时候，浏览器地址栏那里，是有一个小锁头的图标，点开可以看到证书信息。</p><p>证书的原理相当于对网站下发的公钥做一次哈希校验，然后与本机预先存储的证书信息做验证，如果一致，说明对方的公钥是可信的。</p><h3 id="证书是否可信"><a href="#证书是否可信" class="headerlink" title="证书是否可信"></a>证书是否可信</h3><p>证书由证书颁发机构颁发，操作系统会先把可信任的证书颁发机构的根证书集成在操作系统里，这就保证了这些机构颁发的证书是可信的</p><p>如果网站证书校验不通过，那么浏览器地址栏里的小锁头就不见了，取而代之的是一个浏览警告</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞控制详解</title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP四种拥塞控制算法"><a href="#TCP四种拥塞控制算法" class="headerlink" title="TCP四种拥塞控制算法"></a>TCP四种拥塞控制算法</h2><p>*在网络中链路容量（带宽），交换节点中的缓存，处理机等都是网络资源</p><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><p>假定如下条件：</p><ol><li>数据单项传送</li><li>接收方有足够大的缓存空间，因而发送方的窗口大小由网络的拥塞程度来决定</li><li>TCP报文段个数为讨论单位，而不是字节</li></ol><p>tcp Tahoe版本</p><p><img src="/.com//%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1659597200572.png" alt="1659597200572"></p><ol><li><p>发送方维护一个拥塞窗口cwnd，维护原则：没有拥塞，增大；拥塞，减小</p><p>判断是否拥塞一句：没有按时收到应当到达的报文</p></li><li><p>发送方将拥塞窗口作为发送窗口，swnd &#x3D; cwnd</p></li><li><p>维护一个慢开始门限ssthresh，cwnd&lt;ssthresh，慢开始算法，cmnd&gt;ssthresh，拥塞避免算法</p></li></ol><p>初始化：cwnd&#x3D;1，ssthresh&#x3D; 16，向接收端发送1个报文段，接收端收到后返回1个确认报文段</p><p>发送端收到1个确认报文段后，cwnd &#x3D; 2，发送2个报文段，发送方收到后返回2个确认报文段</p><p>接收方收到后，cwnd &#x3D; 4， 返回4个确认报文段</p><p>。。。</p><p>当cwnd指数增长直到等于ssthresh后，开始线性增长，每次增加1个报文段</p><p>当发生超时重传时，网络拥塞，ssthresh &#x3D; 当前cwnd&#x2F;2， cwnd &#x3D; 1，开始慢开始增长</p><p>tcp Reno版本</p><p>快重传</p><p><img src="/.com//%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1659598145129.png" alt="1659598145129"></p><p>快恢复<img src="/.com//%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1659598284439.png" alt="1659598284439"></p><p>完整版</p><p><img src="/.com//%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1659598418151.png" alt="1659598418151"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CDN浅析</title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/</url>
    
    <content type="html"><![CDATA[<h2 id="CDN基础概念"><a href="#CDN基础概念" class="headerlink" title="CDN基础概念"></a>CDN基础概念</h2><p>内容分发网络，分布在各地区的服务器，服务器存储着数据的副本</p><p>CDN系统能够实时的对网络流量、各个节点的连接、网络负载情况以及到用户的距离、响应时间等综合因素将用户的请求重新导向离用户最近的服务器</p><p>目的：使用户能够就近的获取所需内容，解决internet网络拥堵情况，提高用户访问网页速度，减轻源站的负载</p><p>解决跨运营商和跨地狱访问的问题</p><h2 id="CDN回源"><a href="#CDN回源" class="headerlink" title="CDN回源"></a>CDN回源</h2><p>原理：</p><ul><li>源站内容有更新的时候，主动把内容推送到CDN站点</li><li>当用户访问某一个URL时，被解析到的CDN节点没有相应的内容，就会去回源站去获取。如果没人访问，则CDN不会主动去拿</li><li>通常直接用ip进行回源，但如果客户源站由多个ip，ip会经常变化，对于CDN厂商，为了避免频繁修改回源ip，会采用回源域名的方式进行回源，即使原站ip变化了，也不影响配置，其实都是配置时写好的</li></ul><h1 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h1><p>缓存是一个空间换时间的例子，通过使用多余的空间，获取更快的速度</p><p>没有CDN时</p><p><img src="/.com//CDN/1659599839734.png" alt="1659599839734"></p><p>用户访问网站时，会查看本地是否有缓存，这样就不用再次下载全部文件，减少了下载量，提高网页速度</p><p>如果有CDN</p><p><img src="/.com//CDN/1659601440318.png" alt="1659601440318"></p><p>客户端浏览器先检查本地缓存是否过期，如果过期或者没有缓存，则向边缘CDN节点发送请求，CDN节点检查用户请求数据是否有缓存，或者缓存是否过期，如果有，则直接响应用户请求；</p><p>如果已过期或者没有缓存，则CDN向源站发出回源请求，拉取最新数据</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>https浅析</title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/https%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/https%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>Https是在http基础上建立ssl加密层，并对数据传输进行加密，建立一条安全的信息传输通道，并能对网站服务器进行身份认证</p><h2 id="http不安全性"><a href="#http不安全性" class="headerlink" title="http不安全性"></a>http不安全性</h2><h3 id="1-http明文传输，如果被窃听，窃听者能直接获取到报文信息。"><a href="#1-http明文传输，如果被窃听，窃听者能直接获取到报文信息。" class="headerlink" title="1.http明文传输，如果被窃听，窃听者能直接获取到报文信息。"></a>1.http明文传输，如果被窃听，窃听者能直接获取到报文信息。</h3><p>如何窃听http报文？</p><ol><li>标识tcp连接中应用层协议为http协议的连接</li><li>篡改http报文的响应体，通过网关来获取数据包</li><li>抢先回包，将篡改后的数据包抢先正常站点返回的包发送给用户侧，这样正常的数据包在到达后会被丢弃</li></ol><h3 id="2-无法验证报文完整性"><a href="#2-无法验证报文完整性" class="headerlink" title="2.无法验证报文完整性"></a>2.无法验证报文完整性</h3><h3 id="3。不验证通信方的身份"><a href="#3。不验证通信方的身份" class="headerlink" title="3。不验证通信方的身份"></a>3。不验证通信方的身份</h3><h2 id="Https如何解决上述问题"><a href="#Https如何解决上述问题" class="headerlink" title="Https如何解决上述问题"></a>Https如何解决上述问题</h2><p>http协议先和ssl&#x2F;tls协议通信，ssl&#x2F;tls再和tcp通信</p><p>主要依赖TLS&#x2F;SSL的三类基本算法：</p><ol><li>散列函数，进行完整性检验</li><li>和非对称加密，进行身份认证、密钥协商，</li><li>对称加密，对称加密使用协商后的密钥对数据进行加密</li></ol><h3 id="非对称加密缺点"><a href="#非对称加密缺点" class="headerlink" title="非对称加密缺点"></a>非对称加密缺点</h3><ul><li>公钥公开， 因此私钥加密的信息会被公钥破解，窃取到其中的内容</li><li>加密解密耗时，传输效率低、</li><li>公钥不包含服务器信息</li></ul><h3 id="HTTPS采用对称加密和非对称加密的方式"><a href="#HTTPS采用对称加密和非对称加密的方式" class="headerlink" title="HTTPS采用对称加密和非对称加密的方式"></a>HTTPS采用对称加密和非对称加密的方式</h3><p>加密密文使用对称加密</p><p>加密的密钥使用非对称加密，用对方的公钥加密密钥，对方用自己的私钥解密得到密钥</p><p>类似DH密钥交换的形式</p><h3 id="解决报文篡改问题：数字签名"><a href="#解决报文篡改问题：数字签名" class="headerlink" title="解决报文篡改问题：数字签名"></a>解决报文篡改问题：数字签名</h3><ul><li>能够确定签名是由签名方发送来的</li><li>能够确定数据完整性</li></ul><h4 id="数字签名过程"><a href="#数字签名过程" class="headerlink" title="数字签名过程"></a>数字签名过程</h4><ol><li>对消息进行哈希摘要，把哈希摘要用自己的私钥进行加密</li><li>接收方用公钥进行解密，能够确定消息的来源</li><li>将解密后的消息与原始消息的hash进行比对，如果相同，则能确定完整性</li></ol><p>假设 A 给 B发送消息， B收到 了A 的 消息 连同数字签名，通过校验数字签名，发现是A发送的</p><p>前提是B知道A的公钥， 和消息一样，公钥不能在不安全的网络中传输，如何确定公钥是A的呢？</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p><ul><li>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li><li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li><li>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</li><li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li><li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li><li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li></ul><h2 id="Https流程"><a href="#Https流程" class="headerlink" title="Https流程"></a>Https流程</h2><p>1.Client发起一个HTTPS（比如 <code>https://juejin.cn/user/4283353031252967</code>）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。</p><p>2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。</p><p>3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</p><p>4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</p><p>5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</p><p>6.Server使用对称密钥加密“明文内容A”，发送给Client。</p><p>7.Client使用对称密钥解密响应的密文，得到“明文内容A”。</p><p>8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>HTTPS普遍认为性能消耗要大于HTTP，因为 <strong>与纯文本通信相比，加密通信会消耗更多的CPU及内存资源</strong> 。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p><p>但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。举个实际的例子，“双十一”期间，全站HTTPS的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与HTTP持平甚至还有小幅提升，因此HTTPS经过优化之后其实并不慢。</p><p>除此之外， <strong>想要节约购买证书的开销也是原因之一</strong> 。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三次握手和四次挥手详解</title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="/.com//%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/1659517892991.png" alt="1659517892991"></p><p><img src="/.com//%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/1659517897867.png" alt="1659517897867"></p><p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p><pre><code class="hljs">确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</code></pre><p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>【问题3】为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><pre><code class="hljs">现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</code></pre><p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http2.0/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http2.0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/"/>
    <url>/2022/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><a href="https://blog.csdn.net/weixin_43663421/article/details/109209985%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89">https://blog.csdn.net/weixin_43663421/article/details/109209985（重要）</a><br>HTTP协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。</p><hr><h2 id="注意：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在-传输层协议-TCP-之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。"><a href="#注意：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在-传输层协议-TCP-之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。" class="headerlink" title="注意：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在 传输层协议 TCP 之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。"></a>注意：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在 传输层协议 TCP 之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。</h2><p>HTTP 是一种无状态 (stateless) 协议, HTTP协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持HTTP协议的简单性，从而能够快速处理大量的事务, 提高效率。</p><p>然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。由于HTTP是无状态协议，所以必须引入一些技术来记录管理状态，例如 cookie.</p><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h2 id="HTTP-URL"><a href="#HTTP-URL" class="headerlink" title="HTTP URL"></a>HTTP URL</h2><p>HTTP URL 包含了用于查找某个资源的详细信息, 格式如下:<br><code>http://host[&quot;:&quot;port][abs_path]</code></p><h3 id="HTTP请求状态行"><a href="#HTTP请求状态行" class="headerlink" title="HTTP请求状态行"></a>HTTP请求状态行</h3><p>请求行由请求Method, URL 字段和HTTP Version三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的HTTP协议版本例如：<br><code>GET /example.html HTTP/1.1 (CRLF)</code></p><h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><p>消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息</p><h3 id="HTTP请求正文"><a href="#HTTP请求正文" class="headerlink" title="HTTP请求正文"></a>HTTP请求正文</h3><p>只有在发送POST请求时才会有请求正文，GET方法并没有请求正文。</p><h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>HTTP响应也由三部分组成，包括状态行，消息报头，响应正文。</p><h3 id="HTTP响应状态行"><a href="#HTTP响应状态行" class="headerlink" title="HTTP响应状态行"></a>HTTP响应状态行</h3><p>状态行也由三部分组成，包括HTTP协议的版本，状态码，以及对状态码的文本描述。例如：</p><p>HTTP&#x2F;1.1 200 OK （CRLF）</p><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p><p>1xx：指示信息 - 表示请求已接收，继续处理</p><p>2xx：成功 - 表示请求已被成功接收、理解、接受</p><p>3xx：重定向 - 要完成请求必须进行更进一步的操作</p><p>4xx：客户端错误 - 请求有语法错误或请求无法实现</p><p>5xx：服务器端错误 - 服务器未能实现合法的请求</p><p>常见状态代码、状态描述、说明： 200： OK - 客户端请求成功 400： Bad Request - 客户端请求有语法错误，不能被服务器所理解 401： Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403： Forbidden - 服务器收到请求，但是拒绝提供服务 404： Not Found - 请求资源不存在，eg：输入了错误的URL 500： Internal Server Error - 服务器发生不可预期的错误 * 503： Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后,可能恢复正常</p><h2 id="HTTP的五大特点"><a href="#HTTP的五大特点" class="headerlink" title="HTTP的五大特点"></a>HTTP的五大特点</h2><p>1.支持 客户&#x2F;服务器 模式。</p><p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>4.无连接 ：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。早期这么做的原因是请求资源少，追求快。后来通过Connection: Keep-Alive实现长连接</p><p>5.无状态 ：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h2 id="HTTP的不足"><a href="#HTTP的不足" class="headerlink" title="HTTP的不足"></a>HTTP的不足</h2><p>通信使用明文(不加密),内容可能会被窃听</p><p>不验证通信方的身份,因此有可能遭遇伪装</p><p>无法证明报文的完整性,所以有可能已遭篡改</p><h2 id="HTTPS介绍"><a href="#HTTPS介绍" class="headerlink" title="HTTPS介绍"></a>HTTPS介绍</h2><p>HTTP 协议中没有加密机制,但可以通 过和 SSL(Secure Socket Layer, 安全套接层 )或 TLS(Transport Layer Security, 安全层传输协议)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。</p><p><code>HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure ）</code></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>get、post</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/get,post/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/get,post/</url>
    
    <content type="html"><![CDATA[<h1 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h1><p>没有本质区别，只是报文格式不同</p><p>http两种请求方式，用的都是一个传输层协议</p><p>get请求参数在url</p><p>post参数在body</p><table><thead><tr><th>分类</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮&#x2F;刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application&#x2F;x-www-form-urlencoded</td><td>application&#x2F;x-www-form-urlencoded<br> 或 multipart&#x2F;form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；<br>URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL<br> 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h1 id="post比get更安全？"><a href="#post比get更安全？" class="headerlink" title="post比get更安全？"></a>post比get更安全？</h1><p>看起来，get参数暴露在url中，而post存在body中，且post请求没有缓存，</p><p>实际在传输层中，用的都是http明文传输，只要能捉包，都能获取报文信息。</p><p>为了安全，使用https</p><h1 id="get长度"><a href="#get长度" class="headerlink" title="get长度"></a>get长度</h1><p>2048个字符</p><p>浏览器限制长度</p><p>服务端处理过长url会消耗过多资源</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cookie、session、token浅析</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/cookie.seesion.token.jwt/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/cookie.seesion.token.jwt/</url>
    
    <content type="html"><![CDATA[<h1 id="session-cookie的产生"><a href="#session-cookie的产生" class="headerlink" title="session cookie的产生"></a>session cookie的产生</h1><p>我们服务端与客户端进行交互时，需要登陆，需要输入账号密码，服务端才能确定每次的访问请求来自于谁，消息需要发送给谁。</p><p>理论上来说，在不同网页之间切换，都需要登陆认证，输入账号密码。</p><p>但是由于现代互联网的普及，我们访问客户端频率加大，如果每次都输入账号密码，太浪费时间，用户体验也不好。</p><p>这时候就出现了session cookie，由于进行身份认证，服务端会对cookie进行比对。</p><p>易用性和安全性很难做到兼顾，session 和 cookie其实是让大家访问互联网简洁化的产物，牺牲了一定程度的安全性，换来了易用性</p><p>所以如果对方盗走了你的cookie，其实相当于获取了你已经登陆的状态，而不需要多步验证来登陆的环节</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>由于http为无状态协议，每一次请求都是独立的，所以服务端无法确认访问者的信息，无法分辨上一次请求和本次请求是否来自同一个客户端，因此服务端需要进行会话跟踪，去维护一个状态，此状态用于告知服务端请求是否来自同一个客户端，因此出现cookie和session</p><p>cookie存储再客户端，每一次htpp请求的请求头都会携带cookie并发送到服务端，</p><p>cookie不可跨域，每个cookie都会绑定单一的域名</p><pre><code class="hljs">属性：name：valuedomain：域名path：默认为 /，maxAge： cookie销毁时间，单位秒， 如果为负数，则浏览器关闭时销毁httpOnly:设置了就无法通过js读取到cookiesecure：是否仅被安全协议传输</code></pre><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>存储在服务端，并返回给客户端一个seesionID，客户端将sessionID存储再cookie中</p><p>流程：<br>用户第一次请求服务器的时候，服务器根据相关信息，生成session并存储再服务端，返回一个sessionID给客户端，并存储在cookie中。之后每次请求都会查看cookie中有无sessionID。</p><h1 id="token-用于客户端访问API的令牌"><a href="#token-用于客户端访问API的令牌" class="headerlink" title="token(用于客户端访问API的令牌)"></a>token(用于客户端访问API的令牌)</h1><p>特点：<br>服务端无状态，不用像session一样存储在服务端<br>安全，当用户发送用户名和密码给服务端时，验证用户名和密码，成功后会将登陆凭证做一个数字签名token，并发送给客户端，客户端存储在cookie或者localstorage中<br>支持跨程序调用</p><p>每一次向服务端请求资源都要携带token，验证通过则返回相应数据，<br>服务端不需要存储状态，减轻服务端压力</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程及其机制</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h1><p>js借助浏览器内核实现多线程</p><p>js引擎在解析和执行js代码时候只有一个线程</p><p> js在遇到 ajax、settimeout、onclick回调的时候单线程无法实现</p><p>so！js会借助浏览器内核，借用浏览器的辅助线程去实现</p><h2 id="常见的浏览器线程"><a href="#常见的浏览器线程" class="headerlink" title="常见的浏览器线程"></a>常见的浏览器线程</h2><ol><li>js析执行线程（js引擎）</li><li>Gui渲染线程（<strong>渲染引擎</strong>）</li><li>定时器触发线程</li><li>浏览器线程（处理bom操作）</li><li>EventLoop事件轮询处理线程</li><li>Http线程（网络请求）</li><li>。。。</li></ol><p>这么多线程在浏览器内核控制协调下相互配合以保持同步</p><h2 id="浏览器运行机制"><a href="#浏览器运行机制" class="headerlink" title="浏览器运行机制"></a>浏览器运行机制</h2><ol><li>js引擎在主线程解析并执行js代码</li><li>当遇到需要其他线程来配合完成的工作时，js线程会把任务分配给其他线程（分配过程也是同步过程），而js会继续往下执行，不会等待其他线程的任务进度</li><li>其他线程会在自己的线程上处理任务（异步），当处理完成后，会把需要js引擎处理的任务放到callback queue(任务队列)里面、</li><li>在js引擎执行完当前stack里的任务之前，callback queue里面的任务不会被执行</li><li>等js线程的同步任务执行完成，js会去callback queue里面按顺序取其他线程返回来的任务</li></ol><p>总结：</p><p>js线程（领导）</p><p>其他线程（员工）</p><p>js分配任务给员工，但不会等员工任务进度，而是继续做自己的分配工作，</p><p>员工得到任务后，就会执行，执行完成给领导发邮件</p><p>当领导分配完工作后，就去邮箱查看邮件（按顺序），执行邮件里的内容</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>this</title>
    <link href="/2022/08/25/javascript/this/"/>
    <url>/2022/08/25/javascript/this/</url>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol><li>this永远指向一个对象</li><li>this的指向完全取决于函数调用的位置</li><li>this永远在函数执行的时候产生</li></ol><hr><ol><li>在方法中，this 表示该方法所属的对象。</li><li>如果单独使用，this 表示全局对象。</li><li>在函数中，this 表示全局对象。</li><li>在函数中，在严格模式下，this 是未定义的(undefined)。</li><li>在事件中，this 表示接收事件的元素。</li><li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li></ol><hr><pre><code class="hljs">1. 默认，独立调用2. 隐式绑定3. 显示绑定4. new 绑定</code></pre><h2 id="1-默认绑定规则：this默认指向window"><a href="#1-默认绑定规则：this默认指向window" class="headerlink" title="1.默认绑定规则：this默认指向window"></a>1.默认绑定规则：this默认指向window</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//函数独立调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>);<br>&#125;<br><br><span class="hljs-title function_">test</span>() <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="2-隐式绑定规则-谁调用指向谁"><a href="#2-隐式绑定规则-谁调用指向谁" class="headerlink" title="2.隐式绑定规则:谁调用指向谁"></a>2.隐式绑定规则:谁调用指向谁</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//指向obj</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> () &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <br>        &#125;<br>        <span class="hljs-title function_">foo</span>();  <span class="hljs-comment">//独立调用指向window</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//每次函数执行，都会有一个自身的this，且只有在执行时才会有this</span><br><span class="hljs-comment">//obj.test()的this和test()里面foo()的this是两个this</span><br><span class="hljs-comment">//但是两个this可能相等</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-keyword">var</span> circle = &#123;<br>     <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>,<br>     <span class="hljs-title function_">outerDiameter</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">var</span> innerDiameter = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-variable language_">this</span>);   <span class="hljs-comment">//    this指向window</span><br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>); <span class="hljs-comment">// NaN</span><br>       &#125;;<br>       <span class="hljs-comment">// innerDiameter = innerDiameter.bind(this);</span><br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this指向circle</span><br>       <span class="hljs-title function_">innerDiameter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>); <span class="hljs-comment">// 20</span><br>     &#125;,<br>   &#125;;<br>   circle.<span class="hljs-title function_">outerDiameter</span>(); <br></code></pre></td></tr></table></figure><h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">foo</span>: foo;<br>&#125;<br><br>obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span><br><br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// window(相当于独立调用)</span><br></code></pre></td></tr></table></figure><h3 id="改变this"><a href="#改变this" class="headerlink" title="改变this"></a>改变this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">//window</span><br><span class="hljs-comment">//   new fn(); //新创建的实例对象</span><br><span class="hljs-comment">//   fn.call(obj); //obj</span><br><span class="hljs-comment">//   fn(obj);  //window</span><br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br><br><span class="hljs-title function_">bar</span>(obj.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h3 id="api接口中的this指向-可改变"><a href="#api接口中的this指向-可改变" class="headerlink" title="api接口中的this指向(可改变)"></a>api接口中的this指向(可改变)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <br>&#125;, obj);<br></code></pre></td></tr></table></figure><h2 id="3-显示绑定：-call-apply-bind"><a href="#3-显示绑定：-call-apply-bind" class="headerlink" title="3.显示绑定： call apply bind"></a>3.显示绑定： call apply bind</h2><p>改变this指向</p><h2 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4.new绑定"></a>4.new绑定</h2><p>this指向新创建的对象</p><hr><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="*箭头函数"></a>*箭头函数</h2><p>无自己的this指向，this来源于作用域链</p><p>它的取值遵循普通普通变量一样的规则，在函数作用域链中一层一层往上找</p><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>   &#125;;<br>   <span class="hljs-comment">// function test() &#123;</span><br>   <span class="hljs-comment">//   console.log(this);</span><br>   <span class="hljs-comment">// &#125;</span><br>   <span class="hljs-keyword">return</span> test;<br> &#125;<br><br> <span class="hljs-keyword">let</span> obj = &#123;<br>   <span class="hljs-attr">foo</span>: foo,<br> &#125;;<br><br> obj.<span class="hljs-title function_">foo</span>()();    <span class="hljs-comment">//默认绑定，this指向obj</span><br></code></pre></td></tr></table></figure><p>默认绑定规则无效</p><h3 id="2-显示绑定"><a href="#2-显示绑定" class="headerlink" title="2.显示绑定"></a>2.显示绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)   <span class="hljs-comment">//第一个指向window</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">//第二个指向window</span><br>   &#125;;<br>   <span class="hljs-comment">// function test() &#123;</span><br>   <span class="hljs-comment">//   console.log(this);</span><br>   <span class="hljs-comment">// &#125; </span><br>   <span class="hljs-keyword">return</span> test;<br> &#125;<br><br> <span class="hljs-keyword">let</span> obj = &#123;<br>   <span class="hljs-attr">foo</span>: foo,<br> &#125;;<br><br> <span class="hljs-title function_">foo</span>().<span class="hljs-title function_">call</span>(obj);    <span class="hljs-comment">//显示绑定，两次都指向window</span><br></code></pre></td></tr></table></figure><p>显示绑定规则无效，call、apply、bind无法改变箭头函数this指向</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;,<br>&#125;;<br><br>obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>隐式绑定对箭头函数无效</p><h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数不允许作为构造函数使用</p><hr><h2 id="在对象中直接为一个属性赋值this，this指向window"><a href="#在对象中直接为一个属性赋值this，this指向window" class="headerlink" title="* 在对象中直接为一个属性赋值this，this指向window"></a>* 在对象中直接为一个属性赋值this，this指向window</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-variable language_">this</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>worker</title>
    <link href="/2022/08/25/javascript/worker/"/>
    <url>/2022/08/25/javascript/worker/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>由于js是单线程，因此js运行耗时同步任务会导致页面假死，影响用户体验</p><p>worker创建一个新的线程，运行在后台的脚本，不会影响页面的性能</p><p>可以用来处理耗时的任务</p><p>worker一旦创建成功，就会始终运行，能随时响应和主线程的通讯</p><p>比较耗费资源，不应过度使用，当不使用的时候，应该主动关闭。</p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ol><li>必须同源：必须和主线程js脚本在同意路径下</li><li>禁止DOM操作</li><li>通讯限制：woker和主线程不是在同一个上下文中，因此不能直接通讯。需要通过消息通讯。</li><li>禁止DOM传值：主线程与woker通讯时不能传递DOM</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>主线程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      Worker 输出内容：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sendMessage()&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;stopWorker()&quot;</span>&gt;</span>stop!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Worker</span> === <span class="hljs-string">&quot;undefined&quot;</span>)</span><br><span class="language-javascript">      <span class="hljs-comment">// 使用Worker前检查一下浏览器是否支持</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">writeln</span>(<span class="hljs-string">&quot; Sorry! No Web Worker support.. &quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;myworker.js&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>).<span class="hljs-property">innerHTML</span> = ev.<span class="hljs-property">data</span>;</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        w.<span class="hljs-title function_">terminate</span>();</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">filename</span>, error.<span class="hljs-property">lineno</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 发生错误的文件名、行号、错误内容</span></span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> msg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;msg&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-title function_">postMessage</span>(msg.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopWorker</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-title function_">terminate</span>();</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mywoker.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">simpleCount</span>(<span class="hljs-params"></span>) &#123;<br>  i++;<br>  self.<span class="hljs-title function_">postMessage</span>(i);<br>  <span class="hljs-built_in">setTimeout</span>(simpleCount, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">simpleCount</span>();<br><br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">postMessage</span>(ev.<span class="hljs-property">data</span> + <span class="hljs-string">&quot; 呵呵~&quot;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;js/myworker.js&#x27;</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;myworker&#x27;</span>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><p>这是一个在error事件发生时调用的函数，并且通过该函数冒泡worker。示例：worker.onerror&#x3D;function(){….};</p><h4 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h4><p>  这是一个worker中message事件要发生的时候调用的事件。  示例：worker.onmessage&#x3D;function(){….};</p><p>  这个事件一般与postMessage事件同时使用，一个用来发送数据，一个用来接受数据。例如：</p><h4 id="onmessageerror"><a href="#onmessageerror" class="headerlink" title="onmessageerror"></a>onmessageerror</h4><p>在消息传递过程出现错误的属性事件。示例：worker.onmessageerror&#x3D;function(){….};</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="postMessage："><a href="#postMessage：" class="headerlink" title="postMessage："></a>postMessage：</h4><p>向线程worker的内部范围发送消息，可以设置参数，发送给worker线程的数据。在onmessage中接受。</p><h4 id="terminate："><a href="#terminate：" class="headerlink" title="terminate："></a>terminate：</h4><p>过多的开启worker线程非常浪费资源所以在使用过后可以终止它，终止方法使用terminate（）。示例：worker.terminate（）；</p><h4 id="close："><a href="#close：" class="headerlink" title="close："></a>close：</h4><p>除了上面的关闭，如果是在worker线程自身也可以使用self.close（）关闭。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原型理解</title>
    <link href="/2022/08/25/javascript/%E5%8E%9F%E5%9E%8B/"/>
    <url>/2022/08/25/javascript/%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="prototype原型（函数特有属性）"><a href="#prototype原型（函数特有属性）" class="headerlink" title="prototype原型（函数特有属性）"></a>prototype原型（函数特有属性）</h1><p>从一个函数指向一个原型对象<br>每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。<br>prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承，这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。</p><p>prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。</p><h1 id="原型链-（JS原型与原型链继承）"><a href="#原型链-（JS原型与原型链继承）" class="headerlink" title="原型链 （JS原型与原型链继承）"></a>原型链 （JS原型与原型链继承）</h1><p>__________proto___________，一个对象指向另一个对象<br>实例对象与原型之间的连接，叫做原型链。proto( 隐式连接 )</p><p>作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个 方法或属性，那么Javascript引擎将会访问这个对象的proto属性所指向上一个对 象，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象 的proto属性指向的对象进行向上查找，直到这个链表结束。</p><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p><strong><code>delete</code></strong> 操作符会从某个对象上移除指定属性。成功删除的时候会返回 <code>true</code>，否则返回 <code>false</code>。</p><ul><li><p>如果你试图删除的属性不存在，那么 delete 将不会起任何作用，但仍会返回 true</p></li><li><p>如果对象的原型链上有一个与待删除属性同名的属性，那么删除属性之后，对象会使用原型链上的那个属性（也就是说，delete 操作只会在自身的属性上起作用）</p></li><li><p>任何使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a> 声明的属性不能从全局作用域或函数的作用域中删除。</p><ul><li>这样的话，delete 操作不能删除任何在全局作用域中的函数（无论这个函数是来自于函数声明或函数表达式）</li><li>除了在全局作用域中的函数不能被删除，在对象 (object) 中的函数是能够用 delete 操作删除的。</li></ul></li><li><p>任何用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a>声明的属性不能够从它被声明的作用域中删除。</p></li><li><p>不可设置的 (Non-configurable) 属性不能被移除。这意味着像<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math"><code>Math</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a>内置对象的属性以及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>方法设置为不可设置的属性不能被删除。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宏任务微任务</title>
    <link href="/2022/08/25/javascript/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/08/25/javascript/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h1><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>异步任务指的是，不立即进入主线程、而先进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><h2 id="宏任务和微任务："><a href="#宏任务和微任务：" class="headerlink" title="宏任务和微任务："></a>宏任务和微任务：</h2><p>在JavaScript中，任务被分为两种，一种宏任务（MacroTask），一种叫微任务（MicroTask）</p><h2 id="常见的宏任务："><a href="#常见的宏任务：" class="headerlink" title="常见的宏任务："></a><em>常见的宏任务</em>：</h2><p>script全部代码、<em><strong>setTimeout</strong></em>、<em><strong>setInterval</strong></em></p><h2 id="常见的微任务："><a href="#常见的微任务：" class="headerlink" title="常见的微任务："></a><em>常见的微任务</em>：</h2><p><em><strong>Promise中then的回调函数</strong></em>、MutationObserver、<em><strong>Process.nextTick</strong></em></p><p>（1）js代码执行时，先按代码顺序将同步任务压入主执行栈中执行</p><p>（2）遇到异步任务则先将异步任务压入对应的任务队列中（宏队列或微队列）</p><p>（3）同步任务执行完毕后，查看微队列，将微任务一一取出进入主执行栈中执行</p><p>（4）微任务队列清空后，再查看宏队列，只取出第一个宏任务执行，<code>&lt;font color=Red&gt;</code><strong>执行完一个宏任务后，回到第三步的操作</strong><code>&lt;/font&gt;</code></p><p>  这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">//1 4 7 5 2 8 3 6</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1主线程&#x27;</span>);<span class="hljs-comment">//整体script作为第一个宏任务进入主线程</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//setTimeout，其回调函数被分发到宏任务Event Queue（执行规则：从上到下排序，先进先执行）中</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2宏任务&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3宏任务里面的微任务&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4微任务&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5微任务&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//process.nextTick()其回调函数被分发到微任务Event Queue中</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6微任务&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<span class="hljs-comment">//Promise，new Promise直接执行，输出7</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7微任务&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8微任务&#x27;</span>)<span class="hljs-comment">//then被分发到微任务Event Queue中,排在process.nextTick微任务后面。</span><br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//setTimeout，其回调函数被分发到宏任务Event Queue中,排在前面的setTimeout后面</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9宏任务&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;10宏任务里面的微任务&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11微任务&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12微任务&#x27;</span>)<br>    &#125;)<br>&#125;)<br> <br><span class="hljs-comment">//执行结果： 1主线程、7微任务、6微任务、8微任务、2宏任务、4微任务、3宏任务里面的微任务、5微任务、</span><br><span class="hljs-comment">//          9宏任务、11微任务、10宏任务里面的微任务、12微任务</span><br><span class="hljs-comment">// 先执行微任务、再执行宏任务</span><br></code></pre></td></tr></table></figure><h2 id="lt-font-color-Red-gt-总结-lt-font-gt"><a href="#lt-font-color-Red-gt-总结-lt-font-gt" class="headerlink" title="&lt;font color=Red&gt;总结:&lt;/font&gt;"></a><code>&lt;font color=Red&gt;</code>总结:<code>&lt;/font&gt;</code></h2><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>promise 的then回调<br>process.nextTick()</p><p>在newpromise对象的时候，进行的操作是同步操作，不会加入微任务队列</p><h2 id="宏任务（代码块，里面包含很多同步任务、微任务、宏任务）"><a href="#宏任务（代码块，里面包含很多同步任务、微任务、宏任务）" class="headerlink" title="宏任务（代码块，里面包含很多同步任务、微任务、宏任务）"></a>宏任务（代码块，里面包含很多同步任务、微任务、宏任务）</h2><p>setTimeout、setInterval</p><p>宏任务在所有微任务执行完成后，开始执行宏任务代码块</p><h3 id="宏任务代码块里"><a href="#宏任务代码块里" class="headerlink" title="宏任务代码块里"></a>宏任务代码块里</h3><p>1.先执行代码块内部的同步任务<br>2.执行微任务<br>3.所有微任务执行完成后，开始执行下一个宏任务</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/2022/08/25/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/08/25/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h1><p>String、Number、Boolean、null、undefined、Symbol</p><h1 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h1><p>Object、Array、function</p><p>特殊的数据类型：Date、RegExp、Math</p><h1 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h1><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>只能判断简单数据类型和function， 其他复杂数据类型会被判定成object</p><p>null -&gt;object</p><p>undefined -&gt; undefined</p><p>function -&gt; function</p><p>简单数据类型就是简单数据类型</p><p>复杂数据类型判断object</p><p>NaN -&gt; Number</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>A 是否为 B 的实例对象，检测的是原型，但是必须要用构造方法创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);<span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">let</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);<span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call-obj"><a href="#Object-prototype-toString-call-obj" class="headerlink" title="Object.prototype.toString.call( obj );"></a>Object.prototype.toString.call( obj );</h3><p>万能，都能判断</p><p>返回格式       [object Boolean]</p><h3 id="constructor-构造器"><a href="#constructor-构造器" class="headerlink" title="constructor 构造器"></a>constructor 构造器</h3><p>null 和 undefined没有constructor</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文</title>
    <link href="/2022/08/25/javascript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <url>/2022/08/25/javascript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ol><li>全局执行上下文<br>创建一个全局对象window（浏览器），this指向window</li><li>函数执行上下文<br>每执行调用一次函数，产生一个函数执行上下文</li><li>eval上下文，没有了解过</li></ol><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>即调用栈，先进后出，用于存储代码运行时产生的执行上下文</p><p>当运行js脚本时，创建一个全局执行上下文，并压入栈中，并执行栈顶函数</p><p>每当调用一个新的函数，就将该函数的函数上下文压入栈顶，js引擎会执行栈顶函数</p><p>当函数执行完成后，会从栈顶弹出，并执行下一个栈顶元素</p><h1 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h1><ol><li>在全局中，this指向全局对象</li><li>在函数中，this取决于函数被调用的对象。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）</li></ol><h1 id="词法环境和变量环境"><a href="#词法环境和变量环境" class="headerlink" title="词法环境和变量环境"></a>词法环境和变量环境</h1><p>在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="/2022/08/25/javascript/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/08/25/javascript/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝是按位拷贝对象，它会创建一个新对象，对原有对象的成员进行依次拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值</p><p>如果属性是引用类型，拷贝的就是内存地</p><p>因此如果新对象中的某个对象成员改变了值，就会影响到原有的对象</p><h3 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h3><ol><li>Object.assign()</li><li>Array.prototype.concat()和Array.prototype.slice()</li><li>三元运算符</li></ol><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝会另外创建一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>对对象的属性中所有引用类型的值，遍历到是基本类型的值为止。</p><h3 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h3><ol><li>JSON.parse(JSON.stringify())</li><li>递归</li></ol><p> 原理：用JSON.stringify()将对象转成字符串，再用JSON.parse()把字符串解析成对象。</p><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>,<br>        &#125;,<br>      &#125;;<br><br>      <span class="hljs-keyword">let</span> obj2 = &#123; ...obj &#125;;<br>      obj2.<span class="hljs-property">age</span> = <span class="hljs-number">1000</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj&quot;</span>, obj);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj2&quot;</span>, obj2);<br><br>      <span class="hljs-comment">//第一次会输出obj </span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//第二次输出obj2</span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>,<br>        &#125;,<br>      &#125;;<br><br>      <span class="hljs-keyword">let</span> obj2 = &#123; ...obj &#125;;<br>      obj2.<span class="hljs-property">son</span>.<span class="hljs-property">age</span> = <span class="hljs-number">1000</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj&quot;</span>, obj);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj2&quot;</span>, obj2);<br><br>      <span class="hljs-comment">//第一次会输出obj </span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//第二次输出obj2</span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span><br>        &#125;<br>      &#125;<br>如果数组或对象中的元素是引用类型的元素，那么就是浅拷贝<br><br>如何使其成为深拷贝（遍历到基本类型）<br><span class="hljs-keyword">let</span> aa = &#123;<br><span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br><span class="hljs-attr">address</span>: &#123;<br><span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;shanghai&#x27;</span><br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">let</span> bb = &#123;<br>...aa,<br><span class="hljs-attr">address</span>: &#123;...aa.<span class="hljs-property">address</span>&#125;<br>&#125;;<br> <br>bb.<span class="hljs-property">address</span>.<span class="hljs-property">city</span> = <span class="hljs-string">&#x27;shenzhen&#x27;</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aa.<span class="hljs-property">address</span>.<span class="hljs-property">city</span>);  <span class="hljs-comment">// shanghai</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组去重的多种方法</title>
    <link href="/2022/08/25/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/2022/08/25/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>];<br><span class="hljs-keyword">let</span> _arr = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br></code></pre></td></tr></table></figure><h1 id="indexOF"><a href="#indexOF" class="headerlink" title="indexOF"></a>indexOF</h1><h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h1><h1 id="利用两层循环-数组的splice方法"><a href="#利用两层循环-数组的splice方法" class="headerlink" title="利用两层循环+数组的splice方法"></a>利用两层循环+数组的splice方法</h1><h1 id="利用数组的filter-indexOf"><a href="#利用数组的filter-indexOf" class="headerlink" title="利用数组的filter()+indexOf()"></a>利用数组的filter()+indexOf()</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicate</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">removeDuplicate</span>(arr)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// [ 1, 2, &#x27;abc&#x27;, true, false, undefined ]</span><br></code></pre></td></tr></table></figure><h1 id="利用Map"><a href="#利用Map" class="headerlink" title="利用Map()"></a>利用Map()</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicate</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>  <span class="hljs-keyword">const</span> newArr = []<br><br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(item)) &#123; <span class="hljs-comment">// has()用于判断map是否包为item的属性值</span><br>      map.<span class="hljs-title function_">set</span>(item, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 使用set()将item设置到map中，并设置其属性值为true</span><br>      newArr.<span class="hljs-title function_">push</span>(item)<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newArr<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">removeDuplicate</span>(arr)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// [ 1, 2, &#x27;abc&#x27;, true, false, undefined, NaN ]</span><br></code></pre></td></tr></table></figure><h1 id="利用对象"><a href="#利用对象" class="headerlink" title="利用对象"></a>利用对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicate</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> newArr = []<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;<br><br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj[item]) &#123;<br>      newArr.<span class="hljs-title function_">push</span>(item)<br>      obj[item] = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newArr<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">removeDuplicate</span>(arr)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// [ 1, 2, &#x27;abc&#x27;, true, false, undefined, NaN ]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>==、===区别</title>
    <link href="/2022/08/25/javascript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%92%8C==%E3%80%81===/"/>
    <url>/2022/08/25/javascript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%92%8C==%E3%80%81===/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换机制"><a href="#类型转换机制" class="headerlink" title="类型转换机制"></a>类型转换机制</h1><p><code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p><p>但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型</p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p><p>常见的类型转换：</p><ul><li>强制转换（显示转换）</li><li>自动转换（隐式转化)</li></ul><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><p>Number（）</p><p>parseInt（）</p><p>String（）</p><p>Boolean（）</p><h3 id="Number（）"><a href="#Number（）" class="headerlink" title="Number（）"></a>Number（）</h3><p>将任意类型的值转化为数值</p><p>先给出类型转换规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;324&#x27;</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;324abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 空字符串转为0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 布尔值：true 转成 1，false 转成 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// undefined：转成 NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// null：转成0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 对象：通常转换成NaN(除了只包含单个数值的数组)</span><br><span class="hljs-title class_">Number</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为 <code>NaN</code></p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p><code>parseInt</code>相比 <code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;32a3&#x27;</span>) <span class="hljs-comment">//32</span><br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>可以将任意类型的值转化成字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数值：转为相应的字符串</span><br><span class="hljs-title class_">String</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1&quot;</span><br><br><span class="hljs-comment">//字符串：转换后还是原来的值</span><br><span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// &quot;a&quot;</span><br><br><span class="hljs-comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span><br><span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><br><span class="hljs-comment">//undefined：转为字符串&quot;undefined&quot;</span><br><span class="hljs-title class_">String</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;undefined&quot;</span><br><br><span class="hljs-comment">//null：转为字符串&quot;null&quot;</span><br><span class="hljs-title class_">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;null&quot;</span><br><br><span class="hljs-comment">//对象</span><br><span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>何时发生隐式转换？</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li></ul><h4 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h4><ul><li>undefined</li><li>null</li><li>false</li><li>+0</li><li>-0</li><li>NaN</li><li>“”</li></ul><p>除了上面几种会被转化成 <code>false</code>，其他都换被转化成 <code>true</code></p><h4 id="自动转换成字符串"><a href="#自动转换成字符串" class="headerlink" title="自动转换成字符串"></a>自动转换成字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// &#x27;51&#x27;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// &quot;5true&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &quot;5false&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + &#123;&#125; <span class="hljs-comment">// &quot;5[object Object]&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + [] <span class="hljs-comment">// &quot;5&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">// &quot;5function ()&#123;&#125;&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;5undefined&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;5null&quot;</span><br></code></pre></td></tr></table></figure><h4 id="自动转换成数值"><a href="#自动转换成数值" class="headerlink" title="自动转换成数值"></a>自动转换成数值</h4><p>除了 <code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;5&#x27;</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 10</span><br><span class="hljs-literal">true</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;5&#x27;</span> * []    <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> / <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br><span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h1 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h1><p>等于操作符（&#x3D;&#x3D;）在比较中会先进行类型转换，再确定操作数是否相等</p><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">true</span> == <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> == <span class="hljs-number">55</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">valueOf</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">let</span> result1 = (obj == <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>null</code>和 <code>undefined</code>相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果有任一操作数是 <code>NaN</code> ，则相等操作符返回 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <code>true</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">let obj1 = &#123;name:&quot;xxx&quot;&#125;<br>let obj2 = &#123;name:&quot;xxx&quot;&#125;<br>let result1 = (obj1 == obj2 ); // false<br></code></pre></td></tr></table></figure><p>下面进一步做个小结：</p><ul><li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li><li>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</li><li>两个都为引用类型，则比较它们是否指向同一个对象</li><li>null 和 undefined 相等</li><li>存在 NaN 则返回 false</li></ul><h2 id="全等操作符-x3D-x3D-x3D"><a href="#全等操作符-x3D-x3D-x3D" class="headerlink" title="全等操作符&#x3D;&#x3D;&#x3D;"></a>全等操作符&#x3D;&#x3D;&#x3D;</h2><p>只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// false，不相等，因为数据类型不同</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-number">55</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// true，相等，因为数据类型相同值也相同</span><br></code></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 与自身严格相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>)  <span class="hljs-comment">//true</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-literal">undefined</span> === <span class="hljs-literal">undefined</span>)  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>NaN与任何值都为false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>相等操作符（&#x3D;&#x3D;）会做类型转换，再进行值的比较，全等运算符不会做类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// false，不相等，因为数据类型不同</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-number">55</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// true，相等，因为数据类型相同值也相同</span><br></code></pre></td></tr></table></figure><p><code>null</code> 和 <code>undefined</code> 比较，相等操作符（&#x3D;&#x3D;）为 <code>true</code>，全等为 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-literal">null</span>  === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2022/08/25/javascript/%E9%97%AD%E5%8C%85/"/>
    <url>/2022/08/25/javascript/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在js运行的时候，需要一块空间存储定义的变量，这块空间被称作作用域对象（scope object）。</p><p>当在一个函数被执行的时候，函数内部定义的变量被存储在一个作用域对象中，和js普通对象不同的是，我们无法获取作用域对象的引用地址。</p><p>在js中，作用域存储在堆中，因此函数返回后他们还是能够被访问到不被销毁。</p><p>作用域对象也有<em>父级作用域对象</em> 。当试图访问一个对象时，首先访问当前作用域对象，如果没有，则访问父级作用域对象，直到没有父级作用域对象为止，返回ReferenceError。我们把查找变量的过程所经过的作用域对象叫做<em>作用域链。</em></p><p>这个过程很像原型继承，区别是，原型继承查找不到会返回undefined。</p><p>作用域链顶层就是全局对象。</p><h2 id="scope-属性"><a href="#scope-属性" class="headerlink" title="[[scope]]属性"></a>[[scope]]属性</h2><p>函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//-- define local-to-function variables</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">var</span> foo = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inside myFunc&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br><br><span class="hljs-comment">//-- and then, call it:</span><br><span class="hljs-title function_">myFunc</span>();<br></code></pre></td></tr></table></figure><p>myfunc被定义的时候，myfunc标识符（identifier）就被加到了当前的作用域对象中，标识符所引用的是一个函数对象</p><p>函数对象不仅包含函数代码，也包含一些属性，其中就有[[scope]]，指向当前作用域对象</p><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被垃圾回收器回收。但是如果我们在函数当中定义嵌套的函数并且返回，被调用函数的一方所存储呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-keyword">var</span> counter = initial;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">value</span>) &#123;<br>    counter += value;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: increment,<br>    <span class="hljs-attr">get</span>: get<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> myCounter = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());   <span class="hljs-comment">// 返回 100</span><br>myCounter.<span class="hljs-title function_">increment</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());  <span class="hljs-comment">// 返回 105</span><br></code></pre></td></tr></table></figure><p>我们在定义嵌套的函数的时候，这个嵌套的函数的 <code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p><p>如果我们将这个嵌套函数返回，并被另外一个地方的标识符所引用的话，那么这个嵌套函数及其 <code>[[scope]]</code>所引用的作用域对象就不会被垃圾回收所销毁。</p><p><code>increment</code>和 <code>get</code>函数都存有指向 <code>createCounter(100) scope</code>的引用。如果 <code>createCounter(100)</code>没有任何返回值，那么 <code>createCounter(100) scope</code>不再被引用，于是就可以被垃圾回收。但是因为 <code>createCounter(100)</code>实际上是有返回值的，并且返回值被存储在了 <code>myCounter</code>中</p><p>所以，<code>createCounter(100)</code>虽然已经返回了，但是它的作用域对象依然存在，可以<strong>且仅只能</strong>被嵌套的函数（<code>increment</code>和 <code>get</code>）所访问</p><p>在 <code>myCounter.get()</code>运行的过程中，作用域链最底层的对象就是 <code>get() scope</code>，这是一个空对象。所以，当 <code>myCounter.get()</code>访问 <code>counter</code>变量时，JavaScript在 <code>get() scope</code>中找不到这个属性，于是就向上到 <code>createCounter(100) scope</code>当中查找。然后，<code>myCounter.get()</code>将这个值返回。</p><p><code>increment(5)</code>的调用创建了一个新的作用域对象，并且其中含有传入的参数 <code>value</code>。当这个函数尝试访问 <code>value</code>的时候，JavaScript立刻就能在当前的作用域对象找到它。然而，这个函数试图访问 <code>counter</code>的时候，JavaScript无法在当前的作用域对象找到它，于是就会在其父作用域 <code>createCounter(100) scope</code>中查找。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何解析js</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90js/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90js/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器如何解析js"><a href="#浏览器如何解析js" class="headerlink" title="浏览器如何解析js"></a>浏览器如何解析js</h1><p>在浏览器中有一个“js解析器”的工具，专门用来解析我们的js代码。</p><ol><li>js预解析</li><li>逐行解析js代码</li></ol><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><pre><code class="hljs">在当前作用域中，JavaScript代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明或者定义</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> v = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;                                <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);                           <br>&#125;<br></code></pre></td></tr></table></figure><p>Var v &#x3D; 10 可以拆分为如下两个过程</p><ol><li>Var v</li><li>V &#x3D; 10</li></ol><p>声明</p><p>var v 就是声明，即在浏览器中声明一个v变量，但是没有初始化</p><p>定义</p><p>v &#x3D; 10 赋值的过程就是定义</p><p>在预解析时，变量只会声明，<br><strong>而函数既会声明也会定义</strong></p><h3 id="同名字段、函数预解析"><a href="#同名字段、函数预解析" class="headerlink" title="同名字段、函数预解析"></a>同名字段、函数预解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-number">10</span>;                                   <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;                                <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);                           <br>&#125;                                              <br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><pre><code class="hljs">输出结果 erro：fn is not a function</code></pre><p>代码执行过程为</p><ol><li>Js引擎预解析，发现fn变量声明</li><li>Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字</li><li>Js引擎预解析将fn和函数体联系在一起</li><li>执行第一句代码，fn定义为10</li><li>Js引擎已经对fn和函数体联系，不再执行fn联系操作</li><li>执行fn()，因为fn是变量不是函数，所以抛出访问异常</li></ol><h3 id="变量提升场景"><a href="#变量提升场景" class="headerlink" title="变量提升场景"></a>变量提升场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123; &#125;<br>    a = <span class="hljs-number">100</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <br>&#125;<br><span class="hljs-title function_">b</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h1><p>当访问一个网站<a href="http://www.baidu.com,会从服务器下载资源并存储到本地,下次访问该网站时,就不需要重新下载资源,只需要去缓存中读取即可/">www.baidu.com，会从服务器下载资源并存储到本地，下次访问该网站时，就不需要重新下载资源，只需要去缓存中读取即可</a></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>缓解服务器压力</li><li>提升性能，打开本地资源速度要快</li><li>减小带宽消耗（访问本地资源也需要带宽）</li></ul><p>web缓存种类：</p><ul><li>浏览器缓存</li><li>CDN缓存</li><li>数据库缓存</li><li>代理服务器缓存</li></ul><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>浏览器在本地计算机中开辟一个内存空间，同时在硬盘中开辟一个数据缓冲区，浏览器的前进与后退通过缓冲区完成</p><ul><li>协商缓存</li><li>强缓存</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>不会访问服务器，访问本地资源，并返回200状态码</p><p>浏览器根据http response header中的expires 或 cache-control字段判断是不是强缓存</p><p>存储在disk cache、memory cache中</p><p>expires：绝对时间</p><p>cache-control：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">max-age：即最大有效时间，max-age=<span class="hljs-number">3600</span>，代表着资源的有效期是<span class="hljs-number">3600</span>秒<br>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br>s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存<br><span class="hljs-keyword">public</span>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><span class="hljs-keyword">private</span>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。<br></code></pre></td></tr></table></figure><p>缺点：如果资源发生了修改，但还是加载了缓存中的资源，导致资源没有更新</p><p>解决：更改资源名称</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效后，浏览器携带header缓存标识来向服务端发送请求，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified&#x2F;IF-Modified-Since、Etag&#x2F;IF-None-Match），询问服务端是否用缓存</p><p>协商缓存生效，返回304</p><p>协商缓存失效，返回200，服务器返回资源</p><h3 id="如何设置协商缓存？"><a href="#如何设置协商缓存？" class="headerlink" title="如何设置协商缓存？"></a><strong>如何设置协商缓存？</strong></h3><h4 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h4><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。</p><h4 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag &#x2F; If-None-Match"></a>Etag &#x2F; If-None-Match</h4><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。</p><h5 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a><strong>为什么要有Etag</strong></h5><h5 id="HTTP1-1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题："><a href="#HTTP1-1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：" class="headerlink" title="HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题："></a><a href="http://caibaojian.com/t/http" title="View all posts in HTTP">HTTP</a>1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</h5><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p><p>　　　　　　　　某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p><p>　　　　　　　　某些服务器不能精确的得到文件的最后修改时间。</p><h2 id="缓存工作流程"><a href="#缓存工作流程" class="headerlink" title="缓存工作流程"></a>缓存工作流程</h2><p>　<strong>浏览器在第一次请求发生后，再次请求时：</strong></p><p>　1.  浏览器会先获取该资源缓存的header信息，根据其中的 <code>expires</code>和 <code>cache-control</code>判断是否命中 <code>强缓存）</code>，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；</p><p>　2.  如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified&#x2F;IF-Modified-Since、Etag&#x2F;IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</p><h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><ul><li>HTML: 协商缓存；</li><li>css、js、图片：强缓存，文件名带上hash。</li></ul><h2 id="强缓存与协商缓存的区别"><a href="#强缓存与协商缓存的区别" class="headerlink" title="强缓存与协商缓存的区别"></a>强缓存与协商缓存的区别</h2><ol><li>强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。</li><li>大部分web服务器都默认开启协商缓存。</li></ol><h2 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h2><ol><li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li><li>浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React源码浅析</title>
    <link href="/2022/08/25/react/react%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/25/react/react%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h1><p>表面是html， 实际上是通过Babel转换成js语句，通过React.createElement api建立虚拟dom</p><p>每个 JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖。</p><p>是 <code>React.createElement(component, props, ...children)</code>的返回值</p><p>虚拟节点三个参数： type   props   children</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//jsx</span><br><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;greeting&quot;</span>&gt;</span></span><br><span class="language-xml">    Hello, world!</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">//实际上</span><br><span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>&#125;,<br>  <span class="hljs-string">&#x27;Hello, world!&#x27;</span><br>);<br><br><span class="hljs-comment">//生成树，描述每个节点， 递归调用</span><br><span class="hljs-keyword">const</span> element = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>,<br>    <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello, world!&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compoment</span> &#123;<br>    <span class="hljs-comment">//区别class组件和function组件</span><br>    <span class="hljs-keyword">static</span> isReactComponent = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props;<br>    &#125;<br>    <span class="hljs-title function_">setState</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//异步更新 </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, props, ...children</span>) &#123;<br>  <span class="hljs-comment">//判断虚拟dom的类型</span><br>  <span class="hljs-keyword">let</span> vtype;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//普通元素 如 div span</span><br>    vtype = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (type.<span class="hljs-property">isReactCompoment</span>) &#123;<br>      <span class="hljs-comment">//class组件</span><br>      vtype = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//函数式组件</span><br>      vtype = <span class="hljs-number">3</span>;<br>    &#125;<br>  &#125;<br>  props.<span class="hljs-property">children</span> = children;<br>  <span class="hljs-comment">//props中存储的就是虚拟dom的树，是一个很庞大的对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createVnode</span>(vtype, type, props);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initVnode</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; vtype, type, props &#125; = vnode;<br>  <span class="hljs-keyword">if</span> (!vtype) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vtype == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//普通div</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">initVelment</span>(vnode);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vtype == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">initFuncComp</span>(vnode);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vtype == <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">initClassComp</span>(vnode);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//初始化普通div类dom</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initVelment</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, props &#125; = vnode;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(type);<br>  <span class="hljs-keyword">const</span> &#123; key, style, children, ...reset &#125; = props;<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reset).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> &#123;<br>    node.<span class="hljs-title function_">setAttribute</span>(k, reset[k]);<br>  &#125;);<br><br>  <span class="hljs-title function_">initVchildren</span>(node, children);<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-comment">//初始化子元素</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initVchildren</span>(<span class="hljs-params">node, children</span>) &#123;<br>  children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>    node.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">initVnode</span>(c));<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initFuncComp</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, props &#125; = vnode;<br>  <span class="hljs-keyword">let</span> newNode = <span class="hljs-title function_">type</span>(props)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">initVnode</span>(newNode);<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initClassComp</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, props &#125; = vnode;<br>  <span class="hljs-keyword">let</span> compoment = <span class="hljs-keyword">new</span> <span class="hljs-title function_">type</span>(props);<br>  <span class="hljs-keyword">const</span> newNode = compoment.<span class="hljs-title function_">render</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">initVnode</span>(newNode);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vdom, container</span>) &#123;<br>  <span class="hljs-keyword">let</span> rootNode = <span class="hljs-title function_">initVnode</span>(vdom);<br>  container.<span class="hljs-title function_">appendChild</span>(rootNode);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器浅析</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>Trident 俗称IE内核 IE浏览器<br>Gecko 俗称Firefox内核 火狐浏览器<br>Webkit Safari浏览器<br>Blink Chrome浏览器 Oprea浏览器（Blink是由Webkit衍生而来）</p><h1 id="Cookie、sessionStorage、localStorage的区别"><a href="#Cookie、sessionStorage、localStorage的区别" class="headerlink" title="Cookie、sessionStorage、localStorage的区别"></a>Cookie、sessionStorage、localStorage的区别</h1><p>共同点：都是保存在浏览器端，并且是同源的</p><p>区别：作用域不同</p><p>localStorage在所有同源窗口中都是共享的，同浏览器无法共享local和session的信息，同浏览器下，local可以在不同页面 (指的是相同域名和端口的下的不同页面) 共享相同的local数据，</p><p>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面，不同页面或标签页间无法共享sessionStorage的信息，需要注意页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p><p>cookie也是在所有同源窗口中都是共享的，cookie在不设置过期时间的前提下，只在当前的会话有效，</p><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；<br>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>分为 seesion cookies（会话cookie，临时）和 permanent cookies （持久cookie）</p><p>默认在浏览器关闭时，会话cookie删除</p><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）<br>cookie属性：</p><pre><code class="hljs">Domain(域)：Cookie的域；浏览器只向指定域中的服务器主机名发送Cookie，这样服务器就将Cookie限制在了特定的域中。jianshu.com域就与jianshu1.jianshu.com和jianshu1.jianshu2.jianshu.com相匹配，但与js.com就不匹配了。Path(路径)：通过这个属性可以为服务器上特定的文档分配Cookie，如果Path属性是一个URL路径前缀，就可以附加一个Cookie，路径/foo，与/foobar和foo/bar.html相匹配，路径&quot;/&quot;与域名中所有的内容都匹配。Secure(安全)：是否只有在HTTP使用SSL连接时才发送这个Cookie；expires(过期)：从格林尼治标准时间1970年1月1日00：00：00开始的过期秒数；如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。name(名字)：Cookie变量的名字；value(值)：Cookie变量的值；</code></pre><p><img src="/.com//pic1.png" alt="pic1"></p><p>用户访问网址<a href="http://www.example.com,服务器在浏览器写入一个/">www.example.com，服务器在浏览器写入一个</a> Cookie。这个 Cookie 就会包含<a href="http://www.example.com这个域名,以及根路径/%E3%80%82%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%EF%BC%8C%E8%BF%99%E4%B8%AA">www.example.com这个域名，以及根路径/。这意味着，这个</a> Cookie 对该域名的根路径和它的所有子路径都有效。如果路径设为&#x2F;forums，那么这个 Cookie 只有在访问<a href="http://www.example.com/forums%E5%8F%8A%E5%85%B6%E5%AD%90%E8%B7%AF%E5%BE%84%E6%97%B6%E6%89%8D%E6%9C%89%E6%95%88%E3%80%82%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E6%97%A6%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%B1%E4%BC%9A%E9%99%84%E4%B8%8A%E8%BF%99%E6%AE%B5">www.example.com/forums及其子路径时才有效。以后，浏览器一旦访问这个路径，浏览器就会附上这段</a> Cookie 发送给服务器。</p><p>浏览器可以设置不接受 Cookie，也可以设置不向服务器发送 Cookie</p><h3 id="http回应：cookie的生成"><a href="#http回应：cookie的生成" class="headerlink" title="http回应：cookie的生成"></a>http回应：cookie的生成</h3><p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段</p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。（session创建于服务器端，保存于服务器，维护于服务器，每创建一个新的Session，服务器端都会分配一个唯一的ID，并且把这个ID保存到客户端的Cookie中，保存形式是以JsessionID来保存的。）<br>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</p><hr><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>当一个请求的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域<br>为什么会出现跨域问题：<br>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响，可能会受到XSS,CSFR等攻击</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">URL                                      说明                    是否允许通信<br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>http:<span class="hljs-regexp">//</span>www.domain.com/b.js         同一域名，不同文件或路径           允许<br>http:<span class="hljs-regexp">//</span>www.domain.com<span class="hljs-regexp">/lab/</span>c.js<br><br>http:<span class="hljs-regexp">//</span>www.domain.com:<span class="hljs-number">8000</span>/a.js<br>http:<span class="hljs-regexp">//</span>www.domain.com/b.js         同一域名，不同端口                不允许<br> <br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>https:<span class="hljs-regexp">//</span>www.domain.com/b.js        同一域名，不同协议                不允许<br> <br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">4.12</span>/b.js           域名和域名对应相同ip              不允许<br> <br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>http:<span class="hljs-regexp">//</span>x.domain.com/b.js           主域相同，子域不同                不允许<br>http:<span class="hljs-regexp">//</span>domain.com/c.js<br> <br>http:<span class="hljs-regexp">//</span>www.domain1.com/a.js<br>http:<span class="hljs-regexp">//</span>www.domain2.com/b.js        不同域名                         不允许<br><br></code></pre></td></tr></table></figure><h2 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h2><p>1.jsonp，缺点，只能实现get一种请求</p><p>2.cors跨域，目前所有浏览器都支持该功能，cors也成为了主流的跨域解决方案</p><p>3.代理跨域，启动一个代理服务器，实现数据的转发</p><h2 id="jsonp跨域原理"><a href="#jsonp跨域原理" class="headerlink" title="jsonp跨域原理"></a>jsonp跨域原理</h2><p>script资源不受同源策略限制<br>script标签允许访问不同源<br>JSONP利用script标签的加载机制，发送的不是ajax请求，通过script标签获取资源，但是获取的非json数据，而是js格式的数据，所以需要在回调函数中将js解析为json<br>服务器需要返回js格式的数据<br>服务器和客户端都需要配置<br>优点：兼容性好<br>缺点：只支持get请求</p><h2 id="cors跨域原理"><a href="#cors跨域原理" class="headerlink" title="cors跨域原理"></a>cors跨域原理</h2><p>cors跨域只需要在服务端进行配置</p><p>跨域资源共享，基本思想是使用自定义的HTTP头部让浏览器和服务器通信</p><p>分类：浏览器将cors分为两类</p><p>简单请求(head get post)<br>非简单请求</p><h3 id="简单请求-head-get-post"><a href="#简单请求-head-get-post" class="headerlink" title="简单请求(head get post)"></a>简单请求(head get post)</h3><p>客户端在request头部添加一个origin字段，用来说明请求来自哪个源（协议，域名，端口），服务器根据这个值决定是否同意<br>如果服务器不许可，则返回的信息中不会包含Access-Control-Allow-Origin字段，这个错误需要onerror捕获，返回的状态码可能为200<br>如果服务器许可，则服务器返回的响应中会多出Access-Control-Allow-Origin、Access-Control-Allow-Credentials等字段<br>CORS默认不发送cookie，需要发送cookies，则需要服务器指定Access-Control-Allow-Credentials字段，需要在ajax请求中打开withCredentials属性</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>会在正式通信前，增加一次OPTIONS查询请求，预检请求</p><p>简单请求需要CORS服务端对OPTIONS类型的请求做处理，其他与简单请求一致<br>询问服务器，网页所在域名是否在服务器的许可名单中，以及可以使用那些HTTP动词和头信息字段，只有得到肯定答复，浏览器才会发出正式XMLHTTPRequest请求，否则会报错<br>服务器通过预检请求，以后每次浏览器正常CORS请求，都会和简单请求一样，会有一个Origin字段，服务器的回应也会有yieldAccess-Control-Allow-Origin头信息字段</p><h2 id="设置反向代理"><a href="#设置反向代理" class="headerlink" title="设置反向代理"></a>设置反向代理</h2><p>客户端在3000端口</p><p>服务器在5000，</p><p>发送请求到达服务器，由于客户端有ajax返回数据时会卡住</p><p>此时配置代理在3000，由于代理是服务端，没有ajax引擎，因此代理可以接受到5000返回的数据</p><hr><h2 id="输入url到显示页面这个过程发生了什么"><a href="#输入url到显示页面这个过程发生了什么" class="headerlink" title="输入url到显示页面这个过程发生了什么"></a>输入url到显示页面这个过程发生了什么</h2><p>DNS解析<br>TCP连接<br>发送HTTP请求<br>服务器处理请求并返回HTTP报文<br>浏览器解析渲染页面<br>连接结束<br>详细描述</p><p>1.根据URL域名寻找服务器ip，浏览器 <code>&lt;font color=red&gt;</code>首先在缓存中查找 <code>&lt;/font&gt;</code>，查找的顺序是浏览器缓存→系统缓存→路由器缓存，缓存中查找不到则去 <code>&lt;font color=red&gt;</code>系统的hosts文件中查找 <code>&lt;/font&gt;</code>，没有则 <code>&lt;font color=red&gt;</code>查询DNS服务器 <code>&lt;/font&gt;</code><br>2.得到ip地址后，接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息。浏览器根据ip和相应端口号.<code>&lt;font color=red&gt;</code>构建一个http请求 <code>&lt;/font&gt;</code>并将该http请求 <code>&lt;font color=red&gt;</code>封装在一个tcp包中 <code>&lt;/font&gt;</code>，这个tcp包依次经过传输层、网络层、数据链路层、物理层到达服务器，<code>&lt;font color=red&gt;</code>服务器解析 <code>&lt;/font&gt;</code>这个请求并作出响应，返回相应的html给浏览器<br>3.浏览器根据返回的html来 <code>&lt;font color=red&gt;</code>构建DOM树 <code>&lt;/font&gt;</code>，构建DOM树的过程中如果遇到图片、音视频等资源会并行下载，如果遇到js脚本或外部js连接，则会停止DOM树的构建去执行和下载相应js脚本，这会造成 <code>&lt;font color=red&gt;</code>阻塞 <code>&lt;/font&gt;</code>；之后根据外部样式、内部样式、内联样式构建CSSOM树，构建完成后和DOM树合并成渲染树，主要目的是排除非视觉节点，比如script、meta标签和排除display为none的节点<br>4.进行布局，确定各个元素的位置和尺寸，然后渲染页面，显示给用户<br>5.、关闭 TCP 连接,tcp四次挥手<br>5.上述所有请求中都会涉及http缓存机制</p><hr><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p>1.浏览器会将HTML解析成一个DOM树<br>    ~根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。<br>    ~在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕</p><p>2.将CSS解析成 CSS Rule Tree<br>-解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。<br>-浏览器在 CSS 规则树生成之前不会进行渲染。</p><p>3.根据DOM树和CSSOM来构造 Rendering Tree<br>-DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。<br>-精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</p><p>4.有了Rendering Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为布局layout，顾名思义就是计算出每个节点在屏幕中的位置<br>-布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸<br>-回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</p><p>5.再下一步就是绘制，将Rendering Tree的各个节点绘制到屏幕上<br>-绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。<br>-重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。<br>-回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</p><hr><h2 id="手写Ajax"><a href="#手写Ajax" class="headerlink" title="手写Ajax"></a>手写Ajax</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">funtion <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>)&#123;<br>    <span class="hljs-comment">//1.创建ajax对象</span><br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>    <span class="hljs-comment">//2.连接服务器,open(方法、文件名、异步传输）</span><br>    <span class="hljs-comment">//方法：传输方式是get方式还是post方式。</span><br>    <span class="hljs-comment">//文件名：告诉服务器要读哪个文件</span><br>    <span class="hljs-comment">//异步传输：1.异步：多件事一件一件的做；2.同步：多件事情一起进行</span><br>    <span class="hljs-comment">//但是js里面的同步和异步和现实的同步异步相反。1.同步：多件事一件一件的做；2.异步：多件事情一起进行</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, url, <span class="hljs-literal">true</span>)<br>    <span class="hljs-comment">//3.发送请求</span><br>    xhr.<span class="hljs-title function_">send</span>()<br>    <span class="hljs-comment">//4.接收返回,客户端和服务器端有交互的时候会调用onreadystatechange</span><br>    xhr.<span class="hljs-property">onreadyStatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//未初始化 ，没有发送send 1  载入开始 调用send 发起请求  2  载入完成 send完成 收到响应内容 3  交互 解析系响应内容 4  完成</span><br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功&#x27;</span>+xhr.<span class="hljs-property">responseText</span>)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">状态值描述<br><span class="hljs-number">0</span>请求还未初始化，还未调用<span class="hljs-built_in">open</span>( )<br><span class="hljs-number">1</span>请求已建立但未发送，还未调用<span class="hljs-built_in">send</span>( )<br><span class="hljs-number">2</span>接受原始响应数据，为解析做准备<br><span class="hljs-number">3</span>正在解析数据,根据响应头部返回的MIME类型把数据转换成能通过responseText等形式存取的格式<br><span class="hljs-number">4</span>响应完成，数据解析完成<br></code></pre></td></tr></table></figure><hr><h2 id="提升页面性能"><a href="#提升页面性能" class="headerlink" title="提升页面性能"></a>提升页面性能</h2><ul><li>资源压缩合并，减少HTTP请求</li><li>使用CDN，内容分发网络</li><li>预解析DNS</li><li>非核心代码异步加载</li></ul><hr><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>缓存策略都是通过设置 HTTP Header 来实现的。<br>缓存策略的分类：</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><p>Expires<br>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Cache-Control<br>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当 Cache-Control:max-age&#x3D;300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Expires和Cache-Control两者区别<br>其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires ；</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效，返回304和Not Modified<br>协商缓存失效，返回200和请求结果</p><p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p><p>Last-Modified和If-Modified-Since<br>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified 的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</p><p>ETag和If-None-Match<br>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><h3 id="两者之间对比"><a href="#两者之间对比" class="headerlink" title="两者之间对比"></a>两者之间对比</h3><p>首先在精确度上，Etag要优于Last-Modified。<br>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>第三在优先级上，服务器校验优先考虑Etag</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified &#x2F; If-Modified-Since和Etag &#x2F; If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p><h3 id="from-memory-cache和from-disk-cache的区别"><a href="#from-memory-cache和from-disk-cache的区别" class="headerlink" title="from memory cache和from disk cache的区别"></a>from memory cache和from disk cache的区别</h3><p>在chrome浏览器中的控制台Network中size栏通常会有三种状态<br>1.from memory cache<br>2.from disk cache<br>3.资源本身的大小(如：1.5k)<br>三种的区别：</p><p>from memory cache ：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况。<br>from disk cache ：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache<br>资源本身大小数值 ：当http状态为200是实实在在从浏览器获取的资源，当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的</p><hr><h2 id="前端中的事件流"><a href="#前端中的事件流" class="headerlink" title="前端中的事件流"></a>前端中的事件流</h2><p>事件流描述的是从页面中接收事件的顺序<br>事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。<br>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。<br>事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被依次触发。<br>事件流的3个阶段：</p><ul><li>事件捕获阶段（事件从 Document 节点 自上而下 向目标节点传播的阶段）<br>捕获的流程为：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素。</li><li>处于目标阶段（真正的目标节点正在处理事件的阶段）</li><li>事件冒泡阶段（事件从目标节点 自下而上 向 Document 节点传播的阶段）<br>冒泡的流程为：目标元素 -&gt; … -&gt; body -&gt; html -&gt; document -&gt; window。<br>阻止事件的默认行为</li><li>return false</li><li>event.preventDefault()<br>阻止事件冒泡</li><li>return false</li><li>w3c：event.stopPropagation()</li><li>ie：event.cancelBubble &#x3D; true<br>阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。</li><li>event.stopImmediatePropagation()</li></ul><hr><h2 id="图片的懒加载和预加载"><a href="#图片的懒加载和预加载" class="headerlink" title="图片的懒加载和预加载"></a>图片的懒加载和预加载</h2><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。  懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>var、let、const区别</title>
    <link href="/2022/08/25/javascript/var%E3%80%81let%E3%80%81const/"/>
    <url>/2022/08/25/javascript/var%E3%80%81let%E3%80%81const/</url>
    
    <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol><li><p>在ES5中，顶层对象和全局变量是等价的，用var申明全局变量，也是顶层对象</p></li><li><p>存在变量提升</p></li><li><p>能够对变量多次申明，后面申明的变量会覆盖前面的变量</p></li><li><p>不存在块级作用域</p></li><li><p>在函数中用var申明变量， 该变量是局部的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">11</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//30</span><br></code></pre></td></tr></table></figure></li><li><p>如果在函数中不使用var， 改变量为全局变量</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  a = <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>ES6新增</p><ol><li>所申明的变量，只在let命令所在的代码块内有效</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// ReferenceError: a is not defined.</span><br></code></pre></td></tr></table></figure><ol start="2"><li>不存在变量提升</li><li>暂时性锁区,使用 <code>let</code>声明变量前，该变量都不可用</li><li>不允许在相同作用域中重复申明</li></ol><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li>申明一个常量，一旦申明，值不能改变，对于复杂数据类型，保存的是其地址，其地址指向的内容可以改变</li><li>必须初始化</li><li>如果之前用var、let申明过变量，再用const会报错</li><li>暂时性锁区</li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
