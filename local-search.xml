<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>get、post</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/get,post/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/get,post/</url>
    
    <content type="html"><![CDATA[<h1 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h1><p>没有本质区别，只是报文格式不同</p><p>http两种请求方式，用的都是一个传输层协议</p><p>get请求参数在url</p><p>post参数在body</p><table><thead><tr><th>分类</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮&#x2F;刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application&#x2F;x-www-form-urlencoded</td><td>application&#x2F;x-www-form-urlencoded<br /> 或 multipart&#x2F;form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；<br />URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL<br /> 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h1 id="post比get更安全？"><a href="#post比get更安全？" class="headerlink" title="post比get更安全？"></a>post比get更安全？</h1><p>看起来，get参数暴露在url中，而post存在body中，且post请求没有缓存，</p><p>实际在传输层中，用的都是http明文传输，只要能捉包，都能获取报文信息。</p><p>为了安全，使用https</p><h1 id="get长度"><a href="#get长度" class="headerlink" title="get长度"></a>get长度</h1><p>2048个字符</p><p>浏览器限制长度</p><p>服务端处理过长url会消耗过多资源</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cookie、session、token浅析</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/cookie.seesion.token.jwt/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/cookie.seesion.token.jwt/</url>
    
    <content type="html"><![CDATA[<h1 id="session-cookie的产生"><a href="#session-cookie的产生" class="headerlink" title="session cookie的产生"></a>session cookie的产生</h1><p>我们服务端与客户端进行交互时，需要登陆，需要输入账号密码，服务端才能确定每次的访问请求来自于谁，消息需要发送给谁。</p><p>理论上来说，在不同网页之间切换，都需要登陆认证，输入账号密码。</p><p>但是由于现代互联网的普及，我们访问客户端频率加大，如果每次都输入账号密码，太浪费时间，用户体验也不好。</p><p>这时候就出现了session cookie，由于进行身份认证，服务端会对cookie进行比对。</p><p>易用性和安全性很难做到兼顾，session 和 cookie其实是让大家访问互联网简洁化的产物，牺牲了一定程度的安全性，换来了易用性</p><p>所以如果对方盗走了你的cookie，其实相当于获取了你已经登陆的状态，而不需要多步验证来登陆的环节</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>由于http为无状态协议，每一次请求都是独立的，所以服务端无法确认访问者的信息，无法分辨上一次请求和本次请求是否来自同一个客户端，因此服务端需要进行会话跟踪，去维护一个状态，此状态用于告知服务端请求是否来自同一个客户端，因此出现cookie和session</p><p>cookie存储再客户端，每一次htpp请求的请求头都会携带cookie并发送到服务端，</p><p>cookie不可跨域，每个cookie都会绑定单一的域名</p><pre><code class="hljs">属性：name：valuedomain：域名path：默认为 /，maxAge： cookie销毁时间，单位秒， 如果为负数，则浏览器关闭时销毁httpOnly:设置了就无法通过js读取到cookiesecure：是否仅被安全协议传输</code></pre><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>存储在服务端，并返回给客户端一个seesionID，客户端将sessionID存储再cookie中</p><p>流程：<br>用户第一次请求服务器的时候，服务器根据相关信息，生成session并存储再服务端，返回一个sessionID给客户端，并存储在cookie中。之后每次请求都会查看cookie中有无sessionID。</p><h1 id="token-用于客户端访问API的令牌"><a href="#token-用于客户端访问API的令牌" class="headerlink" title="token(用于客户端访问API的令牌)"></a>token(用于客户端访问API的令牌)</h1><p>特点：<br>服务端无状态，不用像session一样存储在服务端<br>安全，当用户发送用户名和密码给服务端时，验证用户名和密码，成功后会将登陆凭证做一个数字签名token，并发送给客户端，客户端存储在cookie或者localstorage中<br>支持跨程序调用</p><p>每一次向服务端请求资源都要携带token，验证通过则返回相应数据，<br>服务端不需要存储状态，减轻服务端压力</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程及其机制</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h1><p>js借助浏览器内核实现多线程</p><p>js引擎在解析和执行js代码时候只有一个线程</p><p> js在遇到 ajax、settimeout、onclick回调的时候单线程无法实现</p><p>so！js会借助浏览器内核，借用浏览器的辅助线程去实现</p><h2 id="常见的浏览器线程"><a href="#常见的浏览器线程" class="headerlink" title="常见的浏览器线程"></a>常见的浏览器线程</h2><ol><li>js析执行线程（js引擎）</li><li>Gui渲染线程（<strong>渲染引擎</strong>）</li><li>定时器触发线程</li><li>浏览器线程（处理bom操作）</li><li>EventLoop事件轮询处理线程</li><li>Http线程（网络请求）</li><li>。。。</li></ol><p>这么多线程在浏览器内核控制协调下相互配合以保持同步</p><h2 id="浏览器运行机制"><a href="#浏览器运行机制" class="headerlink" title="浏览器运行机制"></a>浏览器运行机制</h2><ol><li>js引擎在主线程解析并执行js代码</li><li>当遇到需要其他线程来配合完成的工作时，js线程会把任务分配给其他线程（分配过程也是同步过程），而js会继续往下执行，不会等待其他线程的任务进度</li><li>其他线程会在自己的线程上处理任务（异步），当处理完成后，会把需要js引擎处理的任务放到callback queue(任务队列)里面、</li><li>在js引擎执行完当前stack里的任务之前，callback queue里面的任务不会被执行</li><li>等js线程的同步任务执行完成，js会去callback queue里面按顺序取其他线程返回来的任务</li></ol><p>总结：</p><p>js线程（领导）</p><p>其他线程（员工）</p><p>js分配任务给员工，但不会等员工任务进度，而是继续做自己的分配工作，</p><p>员工得到任务后，就会执行，执行完成给领导发邮件</p><p>当领导分配完工作后，就去邮箱查看邮件（按顺序），执行邮件里的内容</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>this</title>
    <link href="/2022/08/25/javascript/this/"/>
    <url>/2022/08/25/javascript/this/</url>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol><li>this永远指向一个对象</li><li>this的指向完全取决于函数调用的位置</li><li>this永远在函数执行的时候产生</li></ol><hr><ol><li>在方法中，this 表示该方法所属的对象。</li><li>如果单独使用，this 表示全局对象。</li><li>在函数中，this 表示全局对象。</li><li>在函数中，在严格模式下，this 是未定义的(undefined)。</li><li>在事件中，this 表示接收事件的元素。</li><li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li></ol><hr><pre><code class="hljs">1. 默认，独立调用2. 隐式绑定3. 显示绑定4. new 绑定</code></pre><h2 id="1-默认绑定规则：this默认指向window"><a href="#1-默认绑定规则：this默认指向window" class="headerlink" title="1.默认绑定规则：this默认指向window"></a>1.默认绑定规则：this默认指向window</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//函数独立调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>);<br>&#125;<br><br><span class="hljs-title function_">test</span>() <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="2-隐式绑定规则-谁调用指向谁"><a href="#2-隐式绑定规则-谁调用指向谁" class="headerlink" title="2.隐式绑定规则:谁调用指向谁"></a>2.隐式绑定规则:谁调用指向谁</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//指向obj</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> () &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <br>        &#125;<br>        <span class="hljs-title function_">foo</span>();  <span class="hljs-comment">//独立调用指向window</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//每次函数执行，都会有一个自身的this，且只有在执行时才会有this</span><br><span class="hljs-comment">//obj.test()的this和test()里面foo()的this是两个this</span><br><span class="hljs-comment">//但是两个this可能相等</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-keyword">var</span> circle = &#123;<br>     <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>,<br>     <span class="hljs-title function_">outerDiameter</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">var</span> innerDiameter = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-variable language_">this</span>);   <span class="hljs-comment">//    this指向window</span><br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>); <span class="hljs-comment">// NaN</span><br>       &#125;;<br>       <span class="hljs-comment">// innerDiameter = innerDiameter.bind(this);</span><br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this指向circle</span><br>       <span class="hljs-title function_">innerDiameter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>); <span class="hljs-comment">// 20</span><br>     &#125;,<br>   &#125;;<br>   circle.<span class="hljs-title function_">outerDiameter</span>(); <br></code></pre></td></tr></table></figure><h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">foo</span>: foo;<br>&#125;<br><br>obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span><br><br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// window(相当于独立调用)</span><br></code></pre></td></tr></table></figure><h3 id="改变this"><a href="#改变this" class="headerlink" title="改变this"></a>改变this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">//window</span><br><span class="hljs-comment">//   new fn(); //新创建的实例对象</span><br><span class="hljs-comment">//   fn.call(obj); //obj</span><br><span class="hljs-comment">//   fn(obj);  //window</span><br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br><br><span class="hljs-title function_">bar</span>(obj.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h3 id="api接口中的this指向-可改变"><a href="#api接口中的this指向-可改变" class="headerlink" title="api接口中的this指向(可改变)"></a>api接口中的this指向(可改变)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <br>&#125;, obj);<br></code></pre></td></tr></table></figure><h2 id="3-显示绑定：-call-apply-bind"><a href="#3-显示绑定：-call-apply-bind" class="headerlink" title="3.显示绑定： call apply bind"></a>3.显示绑定： call apply bind</h2><p>改变this指向</p><h2 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4.new绑定"></a>4.new绑定</h2><p>this指向新创建的对象</p><hr><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="*箭头函数"></a>*箭头函数</h2><p>无自己的this指向，this来源于作用域链</p><p>它的取值遵循普通普通变量一样的规则，在函数作用域链中一层一层往上找</p><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>   &#125;;<br>   <span class="hljs-comment">// function test() &#123;</span><br>   <span class="hljs-comment">//   console.log(this);</span><br>   <span class="hljs-comment">// &#125;</span><br>   <span class="hljs-keyword">return</span> test;<br> &#125;<br><br> <span class="hljs-keyword">let</span> obj = &#123;<br>   <span class="hljs-attr">foo</span>: foo,<br> &#125;;<br><br> obj.<span class="hljs-title function_">foo</span>()();    <span class="hljs-comment">//默认绑定，this指向obj</span><br></code></pre></td></tr></table></figure><p>默认绑定规则无效</p><h3 id="2-显示绑定"><a href="#2-显示绑定" class="headerlink" title="2.显示绑定"></a>2.显示绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)   <span class="hljs-comment">//第一个指向window</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">//第二个指向window</span><br>   &#125;;<br>   <span class="hljs-comment">// function test() &#123;</span><br>   <span class="hljs-comment">//   console.log(this);</span><br>   <span class="hljs-comment">// &#125; </span><br>   <span class="hljs-keyword">return</span> test;<br> &#125;<br><br> <span class="hljs-keyword">let</span> obj = &#123;<br>   <span class="hljs-attr">foo</span>: foo,<br> &#125;;<br><br> <span class="hljs-title function_">foo</span>().<span class="hljs-title function_">call</span>(obj);    <span class="hljs-comment">//显示绑定，两次都指向window</span><br></code></pre></td></tr></table></figure><p>显示绑定规则无效，call、apply、bind无法改变箭头函数this指向</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;,<br>&#125;;<br><br>obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>隐式绑定对箭头函数无效</p><h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数不允许作为构造函数使用</p><hr><h2 id="在对象中直接为一个属性赋值this，this指向window"><a href="#在对象中直接为一个属性赋值this，this指向window" class="headerlink" title="* 在对象中直接为一个属性赋值this，this指向window"></a>* 在对象中直接为一个属性赋值this，this指向window</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-variable language_">this</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>worker</title>
    <link href="/2022/08/25/javascript/worker/"/>
    <url>/2022/08/25/javascript/worker/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>由于js是单线程，因此js运行耗时同步任务会导致页面假死，影响用户体验</p><p>worker创建一个新的线程，运行在后台的脚本，不会影响页面的性能</p><p>可以用来处理耗时的任务</p><p>worker一旦创建成功，就会始终运行，能随时响应和主线程的通讯</p><p>比较耗费资源，不应过度使用，当不使用的时候，应该主动关闭。</p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ol><li>必须同源：必须和主线程js脚本在同意路径下</li><li>禁止DOM操作</li><li>通讯限制：woker和主线程不是在同一个上下文中，因此不能直接通讯。需要通过消息通讯。</li><li>禁止DOM传值：主线程与woker通讯时不能传递DOM</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>主线程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      Worker 输出内容：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sendMessage()&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;stopWorker()&quot;</span>&gt;</span>stop!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Worker</span> === <span class="hljs-string">&quot;undefined&quot;</span>)</span><br><span class="language-javascript">      <span class="hljs-comment">// 使用Worker前检查一下浏览器是否支持</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">writeln</span>(<span class="hljs-string">&quot; Sorry! No Web Worker support.. &quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;myworker.js&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>).<span class="hljs-property">innerHTML</span> = ev.<span class="hljs-property">data</span>;</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        w.<span class="hljs-title function_">terminate</span>();</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">filename</span>, error.<span class="hljs-property">lineno</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 发生错误的文件名、行号、错误内容</span></span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> msg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;msg&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-title function_">postMessage</span>(msg.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopWorker</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">w</span>.<span class="hljs-title function_">terminate</span>();</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mywoker.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">simpleCount</span>(<span class="hljs-params"></span>) &#123;<br>  i++;<br>  self.<span class="hljs-title function_">postMessage</span>(i);<br>  <span class="hljs-built_in">setTimeout</span>(simpleCount, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">simpleCount</span>();<br><br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">postMessage</span>(ev.<span class="hljs-property">data</span> + <span class="hljs-string">&quot; 呵呵~&quot;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;js/myworker.js&#x27;</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;myworker&#x27;</span>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><p>这是一个在error事件发生时调用的函数，并且通过该函数冒泡worker。示例：worker.onerror&#x3D;function(){….};</p><h4 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h4><p>  这是一个worker中message事件要发生的时候调用的事件。  示例：worker.onmessage&#x3D;function(){….};</p><p>  这个事件一般与postMessage事件同时使用，一个用来发送数据，一个用来接受数据。例如：</p><h4 id="onmessageerror"><a href="#onmessageerror" class="headerlink" title="onmessageerror"></a>onmessageerror</h4><p>在消息传递过程出现错误的属性事件。示例：worker.onmessageerror&#x3D;function(){….};</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="postMessage："><a href="#postMessage：" class="headerlink" title="postMessage："></a>postMessage：</h4><p>向线程worker的内部范围发送消息，可以设置参数，发送给worker线程的数据。在onmessage中接受。</p><h4 id="terminate："><a href="#terminate：" class="headerlink" title="terminate："></a>terminate：</h4><p>过多的开启worker线程非常浪费资源所以在使用过后可以终止它，终止方法使用terminate（）。示例：worker.terminate（）；</p><h4 id="close："><a href="#close：" class="headerlink" title="close："></a>close：</h4><p>除了上面的关闭，如果是在worker线程自身也可以使用self.close（）关闭。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原型理解</title>
    <link href="/2022/08/25/javascript/%E5%8E%9F%E5%9E%8B/"/>
    <url>/2022/08/25/javascript/%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="prototype原型（函数特有属性）"><a href="#prototype原型（函数特有属性）" class="headerlink" title="prototype原型（函数特有属性）"></a>prototype原型（函数特有属性）</h1><p>从一个函数指向一个原型对象<br>每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。<br>prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承，这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。</p><p>prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。</p><h1 id="原型链-（JS原型与原型链继承）"><a href="#原型链-（JS原型与原型链继承）" class="headerlink" title="原型链 （JS原型与原型链继承）"></a>原型链 （JS原型与原型链继承）</h1><p>__________proto___________，一个对象指向另一个对象<br>实例对象与原型之间的连接，叫做原型链。proto( 隐式连接 )</p><p>作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个 方法或属性，那么Javascript引擎将会访问这个对象的proto属性所指向上一个对 象，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象 的proto属性指向的对象进行向上查找，直到这个链表结束。</p><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p><strong><code>delete</code></strong> 操作符会从某个对象上移除指定属性。成功删除的时候会返回 <code>true</code>，否则返回 <code>false</code>。</p><ul><li><p>如果你试图删除的属性不存在，那么 delete 将不会起任何作用，但仍会返回 true</p></li><li><p>如果对象的原型链上有一个与待删除属性同名的属性，那么删除属性之后，对象会使用原型链上的那个属性（也就是说，delete 操作只会在自身的属性上起作用）</p></li><li><p>任何使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a> 声明的属性不能从全局作用域或函数的作用域中删除。</p><ul><li>这样的话，delete 操作不能删除任何在全局作用域中的函数（无论这个函数是来自于函数声明或函数表达式）</li><li>除了在全局作用域中的函数不能被删除，在对象 (object) 中的函数是能够用 delete 操作删除的。</li></ul></li><li><p>任何用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a>声明的属性不能够从它被声明的作用域中删除。</p></li><li><p>不可设置的 (Non-configurable) 属性不能被移除。这意味着像<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math"><code>Math</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a>内置对象的属性以及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>方法设置为不可设置的属性不能被删除。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宏任务微任务</title>
    <link href="/2022/08/25/javascript/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/08/25/javascript/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h1><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>异步任务指的是，不立即进入主线程、而先进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><h2 id="宏任务和微任务："><a href="#宏任务和微任务：" class="headerlink" title="宏任务和微任务："></a>宏任务和微任务：</h2><p>在JavaScript中，任务被分为两种，一种宏任务（MacroTask），一种叫微任务（MicroTask）</p><h2 id="常见的宏任务："><a href="#常见的宏任务：" class="headerlink" title="常见的宏任务："></a><em>常见的宏任务</em>：</h2><p>script全部代码、<em><strong>setTimeout</strong></em>、<em><strong>setInterval</strong></em></p><h2 id="常见的微任务："><a href="#常见的微任务：" class="headerlink" title="常见的微任务："></a><em>常见的微任务</em>：</h2><p><em><strong>Promise中then的回调函数</strong></em>、MutationObserver、<em><strong>Process.nextTick</strong></em></p><p>（1）js代码执行时，先按代码顺序将同步任务压入主执行栈中执行</p><p>（2）遇到异步任务则先将异步任务压入对应的任务队列中（宏队列或微队列）</p><p>（3）同步任务执行完毕后，查看微队列，将微任务一一取出进入主执行栈中执行</p><p>（4）微任务队列清空后，再查看宏队列，只取出第一个宏任务执行，<code>&lt;font color=Red&gt;</code><strong>执行完一个宏任务后，回到第三步的操作</strong><code>&lt;/font&gt;</code></p><p>  这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">//1 4 7 5 2 8 3 6</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1主线程&#x27;</span>);<span class="hljs-comment">//整体script作为第一个宏任务进入主线程</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//setTimeout，其回调函数被分发到宏任务Event Queue（执行规则：从上到下排序，先进先执行）中</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2宏任务&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3宏任务里面的微任务&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4微任务&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5微任务&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//process.nextTick()其回调函数被分发到微任务Event Queue中</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6微任务&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<span class="hljs-comment">//Promise，new Promise直接执行，输出7</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7微任务&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8微任务&#x27;</span>)<span class="hljs-comment">//then被分发到微任务Event Queue中,排在process.nextTick微任务后面。</span><br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//setTimeout，其回调函数被分发到宏任务Event Queue中,排在前面的setTimeout后面</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9宏任务&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;10宏任务里面的微任务&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11微任务&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12微任务&#x27;</span>)<br>    &#125;)<br>&#125;)<br> <br><span class="hljs-comment">//执行结果： 1主线程、7微任务、6微任务、8微任务、2宏任务、4微任务、3宏任务里面的微任务、5微任务、</span><br><span class="hljs-comment">//          9宏任务、11微任务、10宏任务里面的微任务、12微任务</span><br><span class="hljs-comment">// 先执行微任务、再执行宏任务</span><br></code></pre></td></tr></table></figure><h2 id="lt-font-color-Red-gt-总结-lt-font-gt"><a href="#lt-font-color-Red-gt-总结-lt-font-gt" class="headerlink" title="&lt;font color=Red&gt;总结:&lt;/font&gt;"></a><code>&lt;font color=Red&gt;</code>总结:<code>&lt;/font&gt;</code></h2><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>promise 的then回调<br>process.nextTick()</p><p>在newpromise对象的时候，进行的操作是同步操作，不会加入微任务队列</p><h2 id="宏任务（代码块，里面包含很多同步任务、微任务、宏任务）"><a href="#宏任务（代码块，里面包含很多同步任务、微任务、宏任务）" class="headerlink" title="宏任务（代码块，里面包含很多同步任务、微任务、宏任务）"></a>宏任务（代码块，里面包含很多同步任务、微任务、宏任务）</h2><p>setTimeout、setInterval</p><p>宏任务在所有微任务执行完成后，开始执行宏任务代码块</p><h3 id="宏任务代码块里"><a href="#宏任务代码块里" class="headerlink" title="宏任务代码块里"></a>宏任务代码块里</h3><p>1.先执行代码块内部的同步任务<br>2.执行微任务<br>3.所有微任务执行完成后，开始执行下一个宏任务</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文</title>
    <link href="/2022/08/25/javascript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <url>/2022/08/25/javascript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ol><li>全局执行上下文<br>创建一个全局对象window（浏览器），this指向window</li><li>函数执行上下文<br>每执行调用一次函数，产生一个函数执行上下文</li><li>eval上下文，没有了解过</li></ol><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>即调用栈，先进后出，用于存储代码运行时产生的执行上下文</p><p>当运行js脚本时，创建一个全局执行上下文，并压入栈中，并执行栈顶函数</p><p>每当调用一个新的函数，就将该函数的函数上下文压入栈顶，js引擎会执行栈顶函数</p><p>当函数执行完成后，会从栈顶弹出，并执行下一个栈顶元素</p><h1 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h1><ol><li>在全局中，this指向全局对象</li><li>在函数中，this取决于函数被调用的对象。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）</li></ol><h1 id="词法环境和变量环境"><a href="#词法环境和变量环境" class="headerlink" title="词法环境和变量环境"></a>词法环境和变量环境</h1><p>在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/2022/08/25/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/08/25/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h1><p>String、Number、Boolean、null、undefined、Symbol</p><h1 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h1><p>Object、Array、function</p><p>特殊的数据类型：Date、RegExp、Math</p><h1 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h1><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>只能判断简单数据类型和function， 其他复杂数据类型会被判定成object</p><p>null -&gt;object</p><p>undefined -&gt; undefined</p><p>function -&gt; function</p><p>简单数据类型就是简单数据类型</p><p>复杂数据类型判断object</p><p>NaN -&gt; Number</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>A 是否为 B 的实例对象，检测的是原型，但是必须要用构造方法创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);<span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">let</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);<span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call-obj"><a href="#Object-prototype-toString-call-obj" class="headerlink" title="Object.prototype.toString.call( obj );"></a>Object.prototype.toString.call( obj );</h3><p>万能，都能判断</p><p>返回格式       [object Boolean]</p><h3 id="constructor-构造器"><a href="#constructor-构造器" class="headerlink" title="constructor 构造器"></a>constructor 构造器</h3><p>null 和 undefined没有constructor</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组去重的多种方法</title>
    <link href="/2022/08/25/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/2022/08/25/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>];<br><span class="hljs-keyword">let</span> _arr = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br></code></pre></td></tr></table></figure><h1 id="indexOF"><a href="#indexOF" class="headerlink" title="indexOF"></a>indexOF</h1><h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h1><h1 id="利用两层循环-数组的splice方法"><a href="#利用两层循环-数组的splice方法" class="headerlink" title="利用两层循环+数组的splice方法"></a>利用两层循环+数组的splice方法</h1><h1 id="利用数组的filter-indexOf"><a href="#利用数组的filter-indexOf" class="headerlink" title="利用数组的filter()+indexOf()"></a>利用数组的filter()+indexOf()</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicate</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">removeDuplicate</span>(arr)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// [ 1, 2, &#x27;abc&#x27;, true, false, undefined ]</span><br></code></pre></td></tr></table></figure><h1 id="利用Map"><a href="#利用Map" class="headerlink" title="利用Map()"></a>利用Map()</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicate</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>  <span class="hljs-keyword">const</span> newArr = []<br><br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(item)) &#123; <span class="hljs-comment">// has()用于判断map是否包为item的属性值</span><br>      map.<span class="hljs-title function_">set</span>(item, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 使用set()将item设置到map中，并设置其属性值为true</span><br>      newArr.<span class="hljs-title function_">push</span>(item)<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newArr<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">removeDuplicate</span>(arr)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// [ 1, 2, &#x27;abc&#x27;, true, false, undefined, NaN ]</span><br></code></pre></td></tr></table></figure><h1 id="利用对象"><a href="#利用对象" class="headerlink" title="利用对象"></a>利用对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicate</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> newArr = []<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;<br><br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj[item]) &#123;<br>      newArr.<span class="hljs-title function_">push</span>(item)<br>      obj[item] = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newArr<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">removeDuplicate</span>(arr)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// [ 1, 2, &#x27;abc&#x27;, true, false, undefined, NaN ]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="/2022/08/25/javascript/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/08/25/javascript/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝是按位拷贝对象，它会创建一个新对象，对原有对象的成员进行依次拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值</p><p>如果属性是引用类型，拷贝的就是内存地</p><p>因此如果新对象中的某个对象成员改变了值，就会影响到原有的对象</p><h3 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h3><ol><li>Object.assign()</li><li>Array.prototype.concat()和Array.prototype.slice()</li><li>三元运算符</li></ol><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝会另外创建一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>对对象的属性中所有引用类型的值，遍历到是基本类型的值为止。</p><h3 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h3><ol><li>JSON.parse(JSON.stringify())</li><li>递归</li></ol><p> 原理：用JSON.stringify()将对象转成字符串，再用JSON.parse()把字符串解析成对象。</p><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>,<br>        &#125;,<br>      &#125;;<br><br>      <span class="hljs-keyword">let</span> obj2 = &#123; ...obj &#125;;<br>      obj2.<span class="hljs-property">age</span> = <span class="hljs-number">1000</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj&quot;</span>, obj);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj2&quot;</span>, obj2);<br><br>      <span class="hljs-comment">//第一次会输出obj </span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//第二次输出obj2</span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>,<br>        &#125;,<br>      &#125;;<br><br>      <span class="hljs-keyword">let</span> obj2 = &#123; ...obj &#125;;<br>      obj2.<span class="hljs-property">son</span>.<span class="hljs-property">age</span> = <span class="hljs-number">1000</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj&quot;</span>, obj);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj2&quot;</span>, obj2);<br><br>      <span class="hljs-comment">//第一次会输出obj </span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//第二次输出obj2</span><br>      &#123;<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span>, <br>        <span class="hljs-attr">son</span>: &#123;<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">1000</span><br>        &#125;<br>      &#125;<br>如果数组或对象中的元素是引用类型的元素，那么就是浅拷贝<br><br>如何使其成为深拷贝（遍历到基本类型）<br><span class="hljs-keyword">let</span> aa = &#123;<br><span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br><span class="hljs-attr">address</span>: &#123;<br><span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;shanghai&#x27;</span><br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">let</span> bb = &#123;<br>...aa,<br><span class="hljs-attr">address</span>: &#123;...aa.<span class="hljs-property">address</span>&#125;<br>&#125;;<br> <br>bb.<span class="hljs-property">address</span>.<span class="hljs-property">city</span> = <span class="hljs-string">&#x27;shenzhen&#x27;</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aa.<span class="hljs-property">address</span>.<span class="hljs-property">city</span>);  <span class="hljs-comment">// shanghai</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>==、===区别</title>
    <link href="/2022/08/25/javascript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%92%8C==%E3%80%81===/"/>
    <url>/2022/08/25/javascript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%92%8C==%E3%80%81===/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换机制"><a href="#类型转换机制" class="headerlink" title="类型转换机制"></a>类型转换机制</h1><p><code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p><p>但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型</p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p><p>常见的类型转换：</p><ul><li>强制转换（显示转换）</li><li>自动转换（隐式转化)</li></ul><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><p>Number（）</p><p>parseInt（）</p><p>String（）</p><p>Boolean（）</p><h3 id="Number（）"><a href="#Number（）" class="headerlink" title="Number（）"></a>Number（）</h3><p>将任意类型的值转化为数值</p><p>先给出类型转换规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;324&#x27;</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;324abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 空字符串转为0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 布尔值：true 转成 1，false 转成 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// undefined：转成 NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// null：转成0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 对象：通常转换成NaN(除了只包含单个数值的数组)</span><br><span class="hljs-title class_">Number</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为 <code>NaN</code></p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p><code>parseInt</code>相比 <code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;32a3&#x27;</span>) <span class="hljs-comment">//32</span><br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>可以将任意类型的值转化成字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数值：转为相应的字符串</span><br><span class="hljs-title class_">String</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1&quot;</span><br><br><span class="hljs-comment">//字符串：转换后还是原来的值</span><br><span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// &quot;a&quot;</span><br><br><span class="hljs-comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span><br><span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><br><span class="hljs-comment">//undefined：转为字符串&quot;undefined&quot;</span><br><span class="hljs-title class_">String</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;undefined&quot;</span><br><br><span class="hljs-comment">//null：转为字符串&quot;null&quot;</span><br><span class="hljs-title class_">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;null&quot;</span><br><br><span class="hljs-comment">//对象</span><br><span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>何时发生隐式转换？</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li></ul><h4 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h4><ul><li>undefined</li><li>null</li><li>false</li><li>+0</li><li>-0</li><li>NaN</li><li>“”</li></ul><p>除了上面几种会被转化成 <code>false</code>，其他都换被转化成 <code>true</code></p><h4 id="自动转换成字符串"><a href="#自动转换成字符串" class="headerlink" title="自动转换成字符串"></a>自动转换成字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// &#x27;51&#x27;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// &quot;5true&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &quot;5false&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + &#123;&#125; <span class="hljs-comment">// &quot;5[object Object]&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + [] <span class="hljs-comment">// &quot;5&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">// &quot;5function ()&#123;&#125;&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;5undefined&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;5null&quot;</span><br></code></pre></td></tr></table></figure><h4 id="自动转换成数值"><a href="#自动转换成数值" class="headerlink" title="自动转换成数值"></a>自动转换成数值</h4><p>除了 <code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;5&#x27;</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 10</span><br><span class="hljs-literal">true</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;5&#x27;</span> * []    <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> / <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br><span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h1 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h1><p>等于操作符（&#x3D;&#x3D;）在比较中会先进行类型转换，再确定操作数是否相等</p><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">true</span> == <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> == <span class="hljs-number">55</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">valueOf</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">let</span> result1 = (obj == <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>null</code>和 <code>undefined</code>相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果有任一操作数是 <code>NaN</code> ，则相等操作符返回 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <code>true</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">let obj1 = &#123;name:&quot;xxx&quot;&#125;<br>let obj2 = &#123;name:&quot;xxx&quot;&#125;<br>let result1 = (obj1 == obj2 ); // false<br></code></pre></td></tr></table></figure><p>下面进一步做个小结：</p><ul><li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li><li>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</li><li>两个都为引用类型，则比较它们是否指向同一个对象</li><li>null 和 undefined 相等</li><li>存在 NaN 则返回 false</li></ul><h2 id="全等操作符-x3D-x3D-x3D"><a href="#全等操作符-x3D-x3D-x3D" class="headerlink" title="全等操作符&#x3D;&#x3D;&#x3D;"></a>全等操作符&#x3D;&#x3D;&#x3D;</h2><p>只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// false，不相等，因为数据类型不同</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-number">55</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// true，相等，因为数据类型相同值也相同</span><br></code></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 与自身严格相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>)  <span class="hljs-comment">//true</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-literal">undefined</span> === <span class="hljs-literal">undefined</span>)  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>NaN与任何值都为false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>相等操作符（&#x3D;&#x3D;）会做类型转换，再进行值的比较，全等运算符不会做类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// false，不相等，因为数据类型不同</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-number">55</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// true，相等，因为数据类型相同值也相同</span><br></code></pre></td></tr></table></figure><p><code>null</code> 和 <code>undefined</code> 比较，相等操作符（&#x3D;&#x3D;）为 <code>true</code>，全等为 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-literal">null</span>  === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2022/08/25/javascript/%E9%97%AD%E5%8C%85/"/>
    <url>/2022/08/25/javascript/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在js运行的时候，需要一块空间存储定义的变量，这块空间被称作作用域对象（scope object）。</p><p>当在一个函数被执行的时候，函数内部定义的变量被存储在一个作用域对象中，和js普通对象不同的是，我们无法获取作用域对象的引用地址。</p><p>在js中，作用域存储在堆中，因此函数返回后他们还是能够被访问到不被销毁。</p><p>作用域对象也有<em>父级作用域对象</em> 。当试图访问一个对象时，首先访问当前作用域对象，如果没有，则访问父级作用域对象，直到没有父级作用域对象为止，返回ReferenceError。我们把查找变量的过程所经过的作用域对象叫做<em>作用域链。</em></p><p>这个过程很像原型继承，区别是，原型继承查找不到会返回undefined。</p><p>作用域链顶层就是全局对象。</p><h2 id="scope-属性"><a href="#scope-属性" class="headerlink" title="[[scope]]属性"></a>[[scope]]属性</h2><p>函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//-- define local-to-function variables</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">var</span> foo = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inside myFunc&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br><br><span class="hljs-comment">//-- and then, call it:</span><br><span class="hljs-title function_">myFunc</span>();<br></code></pre></td></tr></table></figure><p>myfunc被定义的时候，myfunc标识符（identifier）就被加到了当前的作用域对象中，标识符所引用的是一个函数对象</p><p>函数对象不仅包含函数代码，也包含一些属性，其中就有[[scope]]，指向当前作用域对象</p><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被垃圾回收器回收。但是如果我们在函数当中定义嵌套的函数并且返回，被调用函数的一方所存储呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-keyword">var</span> counter = initial;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">value</span>) &#123;<br>    counter += value;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: increment,<br>    <span class="hljs-attr">get</span>: get<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> myCounter = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());   <span class="hljs-comment">// 返回 100</span><br>myCounter.<span class="hljs-title function_">increment</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());  <span class="hljs-comment">// 返回 105</span><br></code></pre></td></tr></table></figure><p>我们在定义嵌套的函数的时候，这个嵌套的函数的 <code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p><p>如果我们将这个嵌套函数返回，并被另外一个地方的标识符所引用的话，那么这个嵌套函数及其 <code>[[scope]]</code>所引用的作用域对象就不会被垃圾回收所销毁。</p><p><code>increment</code>和 <code>get</code>函数都存有指向 <code>createCounter(100) scope</code>的引用。如果 <code>createCounter(100)</code>没有任何返回值，那么 <code>createCounter(100) scope</code>不再被引用，于是就可以被垃圾回收。但是因为 <code>createCounter(100)</code>实际上是有返回值的，并且返回值被存储在了 <code>myCounter</code>中</p><p>所以，<code>createCounter(100)</code>虽然已经返回了，但是它的作用域对象依然存在，可以<strong>且仅只能</strong>被嵌套的函数（<code>increment</code>和 <code>get</code>）所访问</p><p>在 <code>myCounter.get()</code>运行的过程中，作用域链最底层的对象就是 <code>get() scope</code>，这是一个空对象。所以，当 <code>myCounter.get()</code>访问 <code>counter</code>变量时，JavaScript在 <code>get() scope</code>中找不到这个属性，于是就向上到 <code>createCounter(100) scope</code>当中查找。然后，<code>myCounter.get()</code>将这个值返回。</p><p><code>increment(5)</code>的调用创建了一个新的作用域对象，并且其中含有传入的参数 <code>value</code>。当这个函数尝试访问 <code>value</code>的时候，JavaScript立刻就能在当前的作用域对象找到它。然而，这个函数试图访问 <code>counter</code>的时候，JavaScript无法在当前的作用域对象找到它，于是就会在其父作用域 <code>createCounter(100) scope</code>中查找。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何解析js</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90js/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90js/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器如何解析js"><a href="#浏览器如何解析js" class="headerlink" title="浏览器如何解析js"></a>浏览器如何解析js</h1><p>在浏览器中有一个“js解析器”的工具，专门用来解析我们的js代码。</p><ol><li>js预解析</li><li>逐行解析js代码</li></ol><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><pre><code class="hljs">在当前作用域中，JavaScript代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明或者定义</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> v = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;                                <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);                           <br>&#125;<br></code></pre></td></tr></table></figure><p>Var v &#x3D; 10 可以拆分为如下两个过程</p><ol><li>Var v</li><li>V &#x3D; 10</li></ol><p>声明</p><p>var v 就是声明，即在浏览器中声明一个v变量，但是没有初始化</p><p>定义</p><p>v &#x3D; 10 赋值的过程就是定义</p><p>在预解析时，变量只会声明，<br><strong>而函数既会声明也会定义</strong></p><h3 id="同名字段、函数预解析"><a href="#同名字段、函数预解析" class="headerlink" title="同名字段、函数预解析"></a>同名字段、函数预解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-number">10</span>;                                   <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;                                <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);                           <br>&#125;                                              <br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><pre><code class="hljs">输出结果 erro：fn is not a function</code></pre><p>代码执行过程为</p><ol><li>Js引擎预解析，发现fn变量声明</li><li>Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字</li><li>Js引擎预解析将fn和函数体联系在一起</li><li>执行第一句代码，fn定义为10</li><li>Js引擎已经对fn和函数体联系，不再执行fn联系操作</li><li>执行fn()，因为fn是变量不是函数，所以抛出访问异常</li></ol><h3 id="变量提升场景"><a href="#变量提升场景" class="headerlink" title="变量提升场景"></a>变量提升场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123; &#125;<br>    a = <span class="hljs-number">100</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <br>&#125;<br><span class="hljs-title function_">b</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h1><p>当访问一个网站<a href="http://www.baidu.com,会从服务器下载资源并存储到本地,下次访问该网站时,就不需要重新下载资源,只需要去缓存中读取即可/">www.baidu.com，会从服务器下载资源并存储到本地，下次访问该网站时，就不需要重新下载资源，只需要去缓存中读取即可</a></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>缓解服务器压力</li><li>提升性能，打开本地资源速度要快</li><li>减小带宽消耗（访问本地资源也需要带宽）</li></ul><p>web缓存种类：</p><ul><li>浏览器缓存</li><li>CDN缓存</li><li>数据库缓存</li><li>代理服务器缓存</li></ul><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>浏览器在本地计算机中开辟一个内存空间，同时在硬盘中开辟一个数据缓冲区，浏览器的前进与后退通过缓冲区完成</p><ul><li>协商缓存</li><li>强缓存</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>不会访问服务器，访问本地资源，并返回200状态码</p><p>浏览器根据http response header中的expires 或 cache-control字段判断是不是强缓存</p><p>存储在disk cache、memory cache中</p><p>expires：绝对时间</p><p>cache-control：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">max-age：即最大有效时间，max-age=<span class="hljs-number">3600</span>，代表着资源的有效期是<span class="hljs-number">3600</span>秒<br>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br>s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存<br><span class="hljs-keyword">public</span>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><span class="hljs-keyword">private</span>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。<br></code></pre></td></tr></table></figure><p>缺点：如果资源发生了修改，但还是加载了缓存中的资源，导致资源没有更新</p><p>解决：更改资源名称</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效后，浏览器携带header缓存标识来向服务端发送请求，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified&#x2F;IF-Modified-Since、Etag&#x2F;IF-None-Match），询问服务端是否用缓存</p><p>协商缓存生效，返回304</p><p>协商缓存失效，返回200，服务器返回资源</p><h3 id="如何设置协商缓存？"><a href="#如何设置协商缓存？" class="headerlink" title="如何设置协商缓存？"></a><strong>如何设置协商缓存？</strong></h3><h4 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h4><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。</p><h4 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag &#x2F; If-None-Match"></a>Etag &#x2F; If-None-Match</h4><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。</p><h5 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a><strong>为什么要有Etag</strong></h5><h5 id="HTTP1-1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题："><a href="#HTTP1-1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：" class="headerlink" title="HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题："></a><a href="http://caibaojian.com/t/http" title="View all posts in HTTP">HTTP</a>1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</h5><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p><p>　　　　　　　　某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p><p>　　　　　　　　某些服务器不能精确的得到文件的最后修改时间。</p><h2 id="缓存工作流程"><a href="#缓存工作流程" class="headerlink" title="缓存工作流程"></a>缓存工作流程</h2><p>　<strong>浏览器在第一次请求发生后，再次请求时：</strong></p><p>　1.  浏览器会先获取该资源缓存的header信息，根据其中的 <code>expires</code>和 <code>cache-control</code>判断是否命中 <code>强缓存）</code>，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；</p><p>　2.  如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified&#x2F;IF-Modified-Since、Etag&#x2F;IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</p><h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><ul><li>HTML: 协商缓存；</li><li>css、js、图片：强缓存，文件名带上hash。</li></ul><h2 id="强缓存与协商缓存的区别"><a href="#强缓存与协商缓存的区别" class="headerlink" title="强缓存与协商缓存的区别"></a>强缓存与协商缓存的区别</h2><ol><li>强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。</li><li>大部分web服务器都默认开启协商缓存。</li></ol><h2 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h2><ol><li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li><li>浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React源码浅析</title>
    <link href="/2022/08/25/react/react%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/25/react/react%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h1><p>表面是html， 实际上是通过Babel转换成js语句，通过React.createElement api建立虚拟dom</p><p>每个 JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖。</p><p>是 <code>React.createElement(component, props, ...children)</code>的返回值</p><p>虚拟节点三个参数： type   props   children</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//jsx</span><br><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;greeting&quot;</span>&gt;</span></span><br><span class="language-xml">    Hello, world!</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">//实际上</span><br><span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>&#125;,<br>  <span class="hljs-string">&#x27;Hello, world!&#x27;</span><br>);<br><br><span class="hljs-comment">//生成树，描述每个节点， 递归调用</span><br><span class="hljs-keyword">const</span> element = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>,<br>    <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello, world!&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compoment</span> &#123;<br>    <span class="hljs-comment">//区别class组件和function组件</span><br>    <span class="hljs-keyword">static</span> isReactComponent = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props;<br>    &#125;<br>    <span class="hljs-title function_">setState</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//异步更新 </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, props, ...children</span>) &#123;<br>  <span class="hljs-comment">//判断虚拟dom的类型</span><br>  <span class="hljs-keyword">let</span> vtype;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//普通元素 如 div span</span><br>    vtype = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (type.<span class="hljs-property">isReactCompoment</span>) &#123;<br>      <span class="hljs-comment">//class组件</span><br>      vtype = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//函数式组件</span><br>      vtype = <span class="hljs-number">3</span>;<br>    &#125;<br>  &#125;<br>  props.<span class="hljs-property">children</span> = children;<br>  <span class="hljs-comment">//props中存储的就是虚拟dom的树，是一个很庞大的对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createVnode</span>(vtype, type, props);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initVnode</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; vtype, type, props &#125; = vnode;<br>  <span class="hljs-keyword">if</span> (!vtype) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vtype == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//普通div</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">initVelment</span>(vnode);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vtype == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">initFuncComp</span>(vnode);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vtype == <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">initClassComp</span>(vnode);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//初始化普通div类dom</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initVelment</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, props &#125; = vnode;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(type);<br>  <span class="hljs-keyword">const</span> &#123; key, style, children, ...reset &#125; = props;<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reset).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> &#123;<br>    node.<span class="hljs-title function_">setAttribute</span>(k, reset[k]);<br>  &#125;);<br><br>  <span class="hljs-title function_">initVchildren</span>(node, children);<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-comment">//初始化子元素</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initVchildren</span>(<span class="hljs-params">node, children</span>) &#123;<br>  children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>    node.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">initVnode</span>(c));<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initFuncComp</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, props &#125; = vnode;<br>  <span class="hljs-keyword">let</span> newNode = <span class="hljs-title function_">type</span>(props)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">initVnode</span>(newNode);<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initClassComp</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, props &#125; = vnode;<br>  <span class="hljs-keyword">let</span> compoment = <span class="hljs-keyword">new</span> <span class="hljs-title function_">type</span>(props);<br>  <span class="hljs-keyword">const</span> newNode = compoment.<span class="hljs-title function_">render</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">initVnode</span>(newNode);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vdom, container</span>) &#123;<br>  <span class="hljs-keyword">let</span> rootNode = <span class="hljs-title function_">initVnode</span>(vdom);<br>  container.<span class="hljs-title function_">appendChild</span>(rootNode);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器浅析</title>
    <link href="/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>Trident 俗称IE内核 IE浏览器<br>Gecko 俗称Firefox内核 火狐浏览器<br>Webkit Safari浏览器<br>Blink Chrome浏览器 Oprea浏览器（Blink是由Webkit衍生而来）</p><h1 id="Cookie、sessionStorage、localStorage的区别"><a href="#Cookie、sessionStorage、localStorage的区别" class="headerlink" title="Cookie、sessionStorage、localStorage的区别"></a>Cookie、sessionStorage、localStorage的区别</h1><p>共同点：都是保存在浏览器端，并且是同源的</p><p>区别：作用域不同</p><p>localStorage在所有同源窗口中都是共享的，同浏览器无法共享local和session的信息，同浏览器下，local可以在不同页面 (指的是相同域名和端口的下的不同页面) 共享相同的local数据，</p><p>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面，不同页面或标签页间无法共享sessionStorage的信息，需要注意页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p><p>cookie也是在所有同源窗口中都是共享的，cookie在不设置过期时间的前提下，只在当前的会话有效，</p><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；<br>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>分为 seesion cookies（会话cookie，临时）和 permanent cookies （持久cookie）</p><p>默认在浏览器关闭时，会话cookie删除</p><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）<br>cookie属性：</p><pre><code class="hljs">Domain(域)：Cookie的域；浏览器只向指定域中的服务器主机名发送Cookie，这样服务器就将Cookie限制在了特定的域中。jianshu.com域就与jianshu1.jianshu.com和jianshu1.jianshu2.jianshu.com相匹配，但与js.com就不匹配了。Path(路径)：通过这个属性可以为服务器上特定的文档分配Cookie，如果Path属性是一个URL路径前缀，就可以附加一个Cookie，路径/foo，与/foobar和foo/bar.html相匹配，路径&quot;/&quot;与域名中所有的内容都匹配。Secure(安全)：是否只有在HTTP使用SSL连接时才发送这个Cookie；expires(过期)：从格林尼治标准时间1970年1月1日00：00：00开始的过期秒数；如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。name(名字)：Cookie变量的名字；value(值)：Cookie变量的值；</code></pre><p><img src="/pic/pic1.png" alt="pic1"></p><p>用户访问网址<a href="http://www.example.com,服务器在浏览器写入一个/">www.example.com，服务器在浏览器写入一个</a> Cookie。这个 Cookie 就会包含<a href="http://www.example.com这个域名,以及根路径/%E3%80%82%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%EF%BC%8C%E8%BF%99%E4%B8%AA">www.example.com这个域名，以及根路径/。这意味着，这个</a> Cookie 对该域名的根路径和它的所有子路径都有效。如果路径设为&#x2F;forums，那么这个 Cookie 只有在访问<a href="http://www.example.com/forums%E5%8F%8A%E5%85%B6%E5%AD%90%E8%B7%AF%E5%BE%84%E6%97%B6%E6%89%8D%E6%9C%89%E6%95%88%E3%80%82%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E6%97%A6%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%B1%E4%BC%9A%E9%99%84%E4%B8%8A%E8%BF%99%E6%AE%B5">www.example.com/forums及其子路径时才有效。以后，浏览器一旦访问这个路径，浏览器就会附上这段</a> Cookie 发送给服务器。</p><p>浏览器可以设置不接受 Cookie，也可以设置不向服务器发送 Cookie</p><h3 id="http回应：cookie的生成"><a href="#http回应：cookie的生成" class="headerlink" title="http回应：cookie的生成"></a>http回应：cookie的生成</h3><p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段</p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。（session创建于服务器端，保存于服务器，维护于服务器，每创建一个新的Session，服务器端都会分配一个唯一的ID，并且把这个ID保存到客户端的Cookie中，保存形式是以JsessionID来保存的。）<br>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</p><hr><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>当一个请求的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域<br>为什么会出现跨域问题：<br>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响，可能会受到XSS,CSFR等攻击</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">URL                                      说明                    是否允许通信<br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>http:<span class="hljs-regexp">//</span>www.domain.com/b.js         同一域名，不同文件或路径           允许<br>http:<span class="hljs-regexp">//</span>www.domain.com<span class="hljs-regexp">/lab/</span>c.js<br><br>http:<span class="hljs-regexp">//</span>www.domain.com:<span class="hljs-number">8000</span>/a.js<br>http:<span class="hljs-regexp">//</span>www.domain.com/b.js         同一域名，不同端口                不允许<br> <br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>https:<span class="hljs-regexp">//</span>www.domain.com/b.js        同一域名，不同协议                不允许<br> <br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">4.12</span>/b.js           域名和域名对应相同ip              不允许<br> <br>http:<span class="hljs-regexp">//</span>www.domain.com/a.js<br>http:<span class="hljs-regexp">//</span>x.domain.com/b.js           主域相同，子域不同                不允许<br>http:<span class="hljs-regexp">//</span>domain.com/c.js<br> <br>http:<span class="hljs-regexp">//</span>www.domain1.com/a.js<br>http:<span class="hljs-regexp">//</span>www.domain2.com/b.js        不同域名                         不允许<br><br></code></pre></td></tr></table></figure><h2 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h2><p>1.jsonp，缺点，只能实现get一种请求</p><p>2.cors跨域，目前所有浏览器都支持该功能，cors也成为了主流的跨域解决方案</p><p>3.代理跨域，启动一个代理服务器，实现数据的转发</p><h2 id="jsonp跨域原理"><a href="#jsonp跨域原理" class="headerlink" title="jsonp跨域原理"></a>jsonp跨域原理</h2><p>script资源不受同源策略限制<br>script标签允许访问不同源<br>JSONP利用script标签的加载机制，发送的不是ajax请求，通过script标签获取资源，但是获取的非json数据，而是js格式的数据，所以需要在回调函数中将js解析为json<br>服务器需要返回js格式的数据<br>服务器和客户端都需要配置<br>优点：兼容性好<br>缺点：只支持get请求</p><h2 id="cors跨域原理"><a href="#cors跨域原理" class="headerlink" title="cors跨域原理"></a>cors跨域原理</h2><p>cors跨域只需要在服务端进行配置</p><p>跨域资源共享，基本思想是使用自定义的HTTP头部让浏览器和服务器通信</p><p>分类：浏览器将cors分为两类</p><p>简单请求(head get post)<br>非简单请求</p><h3 id="简单请求-head-get-post"><a href="#简单请求-head-get-post" class="headerlink" title="简单请求(head get post)"></a>简单请求(head get post)</h3><p>客户端在request头部添加一个origin字段，用来说明请求来自哪个源（协议，域名，端口），服务器根据这个值决定是否同意<br>如果服务器不许可，则返回的信息中不会包含Access-Control-Allow-Origin字段，这个错误需要onerror捕获，返回的状态码可能为200<br>如果服务器许可，则服务器返回的响应中会多出Access-Control-Allow-Origin、Access-Control-Allow-Credentials等字段<br>CORS默认不发送cookie，需要发送cookies，则需要服务器指定Access-Control-Allow-Credentials字段，需要在ajax请求中打开withCredentials属性</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>会在正式通信前，增加一次OPTIONS查询请求，预检请求</p><p>简单请求需要CORS服务端对OPTIONS类型的请求做处理，其他与简单请求一致<br>询问服务器，网页所在域名是否在服务器的许可名单中，以及可以使用那些HTTP动词和头信息字段，只有得到肯定答复，浏览器才会发出正式XMLHTTPRequest请求，否则会报错<br>服务器通过预检请求，以后每次浏览器正常CORS请求，都会和简单请求一样，会有一个Origin字段，服务器的回应也会有yieldAccess-Control-Allow-Origin头信息字段</p><h2 id="设置反向代理"><a href="#设置反向代理" class="headerlink" title="设置反向代理"></a>设置反向代理</h2><p>客户端在3000端口</p><p>服务器在5000，</p><p>发送请求到达服务器，由于客户端有ajax返回数据时会卡住</p><p>此时配置代理在3000，由于代理是服务端，没有ajax引擎，因此代理可以接受到5000返回的数据</p><hr><h2 id="输入url到显示页面这个过程发生了什么"><a href="#输入url到显示页面这个过程发生了什么" class="headerlink" title="输入url到显示页面这个过程发生了什么"></a>输入url到显示页面这个过程发生了什么</h2><p>DNS解析<br>TCP连接<br>发送HTTP请求<br>服务器处理请求并返回HTTP报文<br>浏览器解析渲染页面<br>连接结束<br>详细描述</p><p>1.根据URL域名寻找服务器ip，浏览器 <code>&lt;font color=red&gt;</code>首先在缓存中查找 <code>&lt;/font&gt;</code>，查找的顺序是浏览器缓存→系统缓存→路由器缓存，缓存中查找不到则去 <code>&lt;font color=red&gt;</code>系统的hosts文件中查找 <code>&lt;/font&gt;</code>，没有则 <code>&lt;font color=red&gt;</code>查询DNS服务器 <code>&lt;/font&gt;</code><br>2.得到ip地址后，接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息。浏览器根据ip和相应端口号.<code>&lt;font color=red&gt;</code>构建一个http请求 <code>&lt;/font&gt;</code>并将该http请求 <code>&lt;font color=red&gt;</code>封装在一个tcp包中 <code>&lt;/font&gt;</code>，这个tcp包依次经过传输层、网络层、数据链路层、物理层到达服务器，<code>&lt;font color=red&gt;</code>服务器解析 <code>&lt;/font&gt;</code>这个请求并作出响应，返回相应的html给浏览器<br>3.浏览器根据返回的html来 <code>&lt;font color=red&gt;</code>构建DOM树 <code>&lt;/font&gt;</code>，构建DOM树的过程中如果遇到图片、音视频等资源会并行下载，如果遇到js脚本或外部js连接，则会停止DOM树的构建去执行和下载相应js脚本，这会造成 <code>&lt;font color=red&gt;</code>阻塞 <code>&lt;/font&gt;</code>；之后根据外部样式、内部样式、内联样式构建CSSOM树，构建完成后和DOM树合并成渲染树，主要目的是排除非视觉节点，比如script、meta标签和排除display为none的节点<br>4.进行布局，确定各个元素的位置和尺寸，然后渲染页面，显示给用户<br>5.、关闭 TCP 连接,tcp四次挥手<br>5.上述所有请求中都会涉及http缓存机制</p><hr><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p>1.浏览器会将HTML解析成一个DOM树<br>    ~根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。<br>    ~在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕</p><p>2.将CSS解析成 CSS Rule Tree<br>-解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。<br>-浏览器在 CSS 规则树生成之前不会进行渲染。</p><p>3.根据DOM树和CSSOM来构造 Rendering Tree<br>-DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。<br>-精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</p><p>4.有了Rendering Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为布局layout，顾名思义就是计算出每个节点在屏幕中的位置<br>-布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸<br>-回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</p><p>5.再下一步就是绘制，将Rendering Tree的各个节点绘制到屏幕上<br>-绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。<br>-重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。<br>-回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</p><hr><h2 id="手写Ajax"><a href="#手写Ajax" class="headerlink" title="手写Ajax"></a>手写Ajax</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">funtion <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>)&#123;<br>    <span class="hljs-comment">//1.创建ajax对象</span><br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>    <span class="hljs-comment">//2.连接服务器,open(方法、文件名、异步传输）</span><br>    <span class="hljs-comment">//方法：传输方式是get方式还是post方式。</span><br>    <span class="hljs-comment">//文件名：告诉服务器要读哪个文件</span><br>    <span class="hljs-comment">//异步传输：1.异步：多件事一件一件的做；2.同步：多件事情一起进行</span><br>    <span class="hljs-comment">//但是js里面的同步和异步和现实的同步异步相反。1.同步：多件事一件一件的做；2.异步：多件事情一起进行</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, url, <span class="hljs-literal">true</span>)<br>    <span class="hljs-comment">//3.发送请求</span><br>    xhr.<span class="hljs-title function_">send</span>()<br>    <span class="hljs-comment">//4.接收返回,客户端和服务器端有交互的时候会调用onreadystatechange</span><br>    xhr.<span class="hljs-property">onreadyStatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//未初始化 ，没有发送send 1  载入开始 调用send 发起请求  2  载入完成 send完成 收到响应内容 3  交互 解析系响应内容 4  完成</span><br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功&#x27;</span>+xhr.<span class="hljs-property">responseText</span>)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">状态值描述<br><span class="hljs-number">0</span>请求还未初始化，还未调用<span class="hljs-built_in">open</span>( )<br><span class="hljs-number">1</span>请求已建立但未发送，还未调用<span class="hljs-built_in">send</span>( )<br><span class="hljs-number">2</span>接受原始响应数据，为解析做准备<br><span class="hljs-number">3</span>正在解析数据,根据响应头部返回的MIME类型把数据转换成能通过responseText等形式存取的格式<br><span class="hljs-number">4</span>响应完成，数据解析完成<br></code></pre></td></tr></table></figure><hr><h2 id="提升页面性能"><a href="#提升页面性能" class="headerlink" title="提升页面性能"></a>提升页面性能</h2><ul><li>资源压缩合并，减少HTTP请求</li><li>使用CDN，内容分发网络</li><li>预解析DNS</li><li>非核心代码异步加载</li></ul><hr><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>缓存策略都是通过设置 HTTP Header 来实现的。<br>缓存策略的分类：</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><p>Expires<br>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Cache-Control<br>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当 Cache-Control:max-age&#x3D;300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Expires和Cache-Control两者区别<br>其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires ；</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效，返回304和Not Modified<br>协商缓存失效，返回200和请求结果</p><p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p><p>Last-Modified和If-Modified-Since<br>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified 的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</p><p>ETag和If-None-Match<br>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><h3 id="两者之间对比"><a href="#两者之间对比" class="headerlink" title="两者之间对比"></a>两者之间对比</h3><p>首先在精确度上，Etag要优于Last-Modified。<br>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>第三在优先级上，服务器校验优先考虑Etag</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified &#x2F; If-Modified-Since和Etag &#x2F; If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p><h3 id="from-memory-cache和from-disk-cache的区别"><a href="#from-memory-cache和from-disk-cache的区别" class="headerlink" title="from memory cache和from disk cache的区别"></a>from memory cache和from disk cache的区别</h3><p>在chrome浏览器中的控制台Network中size栏通常会有三种状态<br>1.from memory cache<br>2.from disk cache<br>3.资源本身的大小(如：1.5k)<br>三种的区别：</p><p>from memory cache ：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况。<br>from disk cache ：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache<br>资源本身大小数值 ：当http状态为200是实实在在从浏览器获取的资源，当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的</p><hr><h2 id="前端中的事件流"><a href="#前端中的事件流" class="headerlink" title="前端中的事件流"></a>前端中的事件流</h2><p>事件流描述的是从页面中接收事件的顺序<br>事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。<br>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。<br>事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被依次触发。<br>事件流的3个阶段：</p><ul><li>事件捕获阶段（事件从 Document 节点 自上而下 向目标节点传播的阶段）<br>捕获的流程为：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素。</li><li>处于目标阶段（真正的目标节点正在处理事件的阶段）</li><li>事件冒泡阶段（事件从目标节点 自下而上 向 Document 节点传播的阶段）<br>冒泡的流程为：目标元素 -&gt; … -&gt; body -&gt; html -&gt; document -&gt; window。<br>阻止事件的默认行为</li><li>return false</li><li>event.preventDefault()<br>阻止事件冒泡</li><li>return false</li><li>w3c：event.stopPropagation()</li><li>ie：event.cancelBubble &#x3D; true<br>阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。</li><li>event.stopImmediatePropagation()</li></ul><hr><h2 id="图片的懒加载和预加载"><a href="#图片的懒加载和预加载" class="headerlink" title="图片的懒加载和预加载"></a>图片的懒加载和预加载</h2><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。  懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>var、let、const区别</title>
    <link href="/2022/08/25/javascript/var%E3%80%81let%E3%80%81const/"/>
    <url>/2022/08/25/javascript/var%E3%80%81let%E3%80%81const/</url>
    
    <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol><li><p>在ES5中，顶层对象和全局变量是等价的，用var申明全局变量，也是顶层对象</p></li><li><p>存在变量提升</p></li><li><p>能够对变量多次申明，后面申明的变量会覆盖前面的变量</p></li><li><p>不存在块级作用域</p></li><li><p>在函数中用var申明变量， 该变量是局部的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">11</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//30</span><br></code></pre></td></tr></table></figure></li><li><p>如果在函数中不使用var， 改变量为全局变量</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  a = <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>ES6新增</p><ol><li>所申明的变量，只在let命令所在的代码块内有效</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// ReferenceError: a is not defined.</span><br></code></pre></td></tr></table></figure><ol start="2"><li>不存在变量提升</li><li>暂时性锁区,使用 <code>let</code>声明变量前，该变量都不可用</li><li>不允许在相同作用域中重复申明</li></ol><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li>申明一个常量，一旦申明，值不能改变，对于复杂数据类型，保存的是其地址，其地址指向的内容可以改变</li><li>必须初始化</li><li>如果之前用var、let申明过变量，再用const会报错</li><li>暂时性锁区</li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
